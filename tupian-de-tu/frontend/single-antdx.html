<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xobi v3 - 单图创作 (Ant Design X)</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- Ant Design CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/antd@5.15.0/dist/reset.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="assets/css/base.css">

    <!-- Favicon -->
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>图</text></svg>">

    <!-- Config Manager -->
    <script src="assets/js/config-manager.js"></script>

    <!-- Day.js (required by antd) - MUST load first -->
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>

    <!-- React & ReactDOM (UMD) -->
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

    <!-- Ant Design (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/antd@5.15.0/dist/antd.min.js"></script>

    <!-- Ant Design Icons (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/@ant-design/icons@5.2.6/dist/index.umd.js"></script>

    <!-- Babel Standalone for JSX -->
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>

    <style>
        :root {
            /* Portal Light Theme (与门户统一) */
            --bg-primary: #f5f7fb;
            --bg-secondary: #ffffff;
            --bg-tertiary: #fafbfc;
            --bg-elevated: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: rgba(0, 0, 0, 0.55);
            --text-tertiary: rgba(0, 0, 0, 0.35);
            /* Purple Accent (与门户统一) */
            --accent-color: #8B5CF6;
            --accent-color-light: #A78BFA;
            --accent-color-dark: #7C3AED;
            --accent-gradient: linear-gradient(135deg, #8B5CF6 0%, #7C3AED 100%);
            --accent-gradient-hover: linear-gradient(135deg, #A78BFA 0%, #8B5CF6 100%);
            /* Borders & Radius */
            --border-color: #e8e8e8;
            --border-color-light: #f0f0f0;
            --radius-s: 10px;
            --radius-m: 14px;
            --radius-l: 18px;
            --radius-xl: 22px;
            /* Shadows */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.08);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.1);
            --shadow-glow: 0 0 0 3px rgba(139, 92, 246, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', 'Inter', 'Hiragino Sans GB',
                'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        #root {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Override Ant Design styles for dark theme */
        .ant-layout {
            background: var(--bg-primary) !important;
        }

        .ant-layout-header {
            background: var(--bg-secondary) !important;
            border-bottom: 1px solid var(--border-color);
            padding: 0 24px;
            height: 64px;
            line-height: 64px;
        }

        .ant-layout-sider {
            background: var(--bg-secondary) !important;
        }

        .ant-layout-content {
            background: var(--bg-primary) !important;
            overflow: auto;
        }

        .ant-card {
            background: var(--bg-secondary) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: var(--radius-l) !important;
            color: var(--text-primary) !important;
            box-shadow: var(--shadow-sm);
        }

        .ant-card-head {
            border-color: var(--border-color) !important;
            color: var(--text-primary) !important;
            font-size: 16px;
            font-weight: 600;
        }

        .ant-input,
        .ant-input-textarea,
        .ant-input-affix-wrapper,
        .ant-input-affix-wrapper .ant-input,
        .ant-select-selector,
        .ant-segmented,
        .ant-segmented-item,
        .ant-btn {
            background: var(--bg-tertiary) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: var(--radius-m) !important;
            color: var(--text-primary) !important;
            transition: all 0.2s ease;
            font-family: 'PingFang SC', 'Microsoft YaHei', 'Inter', Arial, sans-serif !important;
            letter-spacing: 0 !important;
        }

        .ant-input,
        .ant-input-affix-wrapper .ant-input {
            background: transparent !important;
            color: var(--text-primary) !important;
        }

        .ant-input::placeholder,
        .ant-input-textarea::placeholder {
            color: var(--text-tertiary) !important;
        }

        .ant-input:hover,
        .ant-input-textarea:hover,
        .ant-input-affix-wrapper:hover {
            border-color: var(--border-color-light) !important;
        }

        .ant-input:focus,
        .ant-input-textarea:focus,
        .ant-input-affix-wrapper:focus,
        .ant-input-affix-wrapper-focused {
            border-color: var(--accent-color) !important;
            box-shadow: var(--shadow-glow) !important;
        }

        .ant-input-group-addon {
            background: var(--bg-tertiary) !important;
            border: 1px solid var(--border-color) !important;
            color: var(--text-secondary) !important;
        }

        .ant-segmented {
            background: var(--bg-tertiary) !important;
            border-radius: var(--radius-m) !important;
            padding: 4px !important;
            display: inline-flex !important;
            flex-wrap: wrap !important;
        }

        .ant-segmented-group {
            flex-wrap: wrap !important;
        }

        .ant-segmented-item {
            color: var(--text-secondary) !important;
            border-radius: var(--radius-s) !important;
            transition: all 0.3s ease !important;
            min-height: 28px !important;
            line-height: 28px !important;
        }

        .ant-segmented-item-selected {
            background: var(--accent-color) !important;
            color: white !important;
            box-shadow: var(--shadow-sm) !important;
        }

        .ant-btn-primary {
            background: var(--accent-color) !important;
            color: white !important;
            border: none !important;
            border-radius: var(--radius-m) !important;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: none !important;
        }

        .ant-btn-primary:hover {
            background: var(--accent-color-dark) !important;
            color: white !important;
            transform: none;
            box-shadow: var(--shadow-sm) !important;
        }

        .ant-btn-default {
            background: var(--bg-tertiary) !important;
            border: 1px solid var(--border-color) !important;
            border-radius: var(--radius-m) !important;
            color: var(--text-secondary) !important;
            transition: all 0.3s ease;
        }

        .ant-btn-default:hover {
            border-color: var(--accent-color) !important;
            color: var(--text-primary) !important;
            background: var(--bg-elevated) !important;
            box-shadow: none !important;
        }

        .ant-drawer-content {
            background: var(--bg-secondary) !important;
        }

        .ant-drawer-header {
            background: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }

        .ant-drawer-title {
            color: var(--text-primary) !important;
        }

        .ant-drawer-body {
            background: var(--bg-primary) !important;
        }

        .ant-modal-content {
            background: var(--bg-secondary) !important;
        }

        .ant-modal-header {
            background: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }

        .ant-modal-title {
            color: var(--text-primary) !important;
        }

        .ant-upload.ant-upload-drag {
            background: transparent !important;
            border: 1px dashed var(--border-color) !important;
            border-radius: var(--radius-l) !important;
            transition: all 0.3s ease;
        }

        .ant-upload-drag:hover {
            border-color: var(--accent-color) !important;
            background: rgba(37, 99, 235, 0.04) !important;
            box-shadow: none !important;
        }

        .ant-badge-count {
            background: var(--text-primary) !important;
            color: var(--bg-primary) !important;
        }

        .ant-table {
            background: transparent !important;
            color: var(--text-primary) !important;
        }

        .ant-table-thead>tr>th {
            background: var(--bg-tertiary) !important;
            color: var(--text-secondary) !important;
            border-color: var(--border-color) !important;
        }

        .ant-table-tbody>tr>td {
            border-color: var(--border-color) !important;
        }

        .ant-table-tbody>tr:hover>td {
            background: var(--bg-tertiary) !important;
        }

        /* Custom Upload Area */
        .upload-area {
            min-height: 220px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-color);
            border-radius: var(--radius-m);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: inset 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .upload-area:hover {
            border-color: var(--accent-color);
            background: rgba(138, 43, 226, 0.05);
        }

        .upload-area.has-image {
            border-style: solid;
            cursor: default;
        }

        .upload-area img {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            object-fit: contain;
        }

        .reupload-btn {
            position: absolute;
            bottom: 12px;
            right: 12px;
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .upload-area:hover .reupload-btn {
            opacity: 1;
        }

        /* Canvas Element for tagging */
        .canvas-element {
            position: relative;
        }

        .canvas-element.ctrl-active {
            cursor: crosshair !important;
        }

        .canvas-element.ctrl-active:hover {
            outline: 2px dashed var(--accent-color);
            outline-offset: 2px;
        }

        /* Annotation Overlay */
        .annotation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: crosshair;
            z-index: 10;
            border-radius: var(--node-radius, 0px);
            pointer-events: auto;
            user-select: none;
        }

        .annotation-marker {
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 11;
        }

        .marker-dot {
            width: 12px;
            height: 12px;
            background: #ff4d4f;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .marker-number {
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--accent-color);
            color: white;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
        }

        .marker-tooltip {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Terminal */
        .terminal {
            background: var(--bg-tertiary);
            padding: 12px;
            border-radius: var(--radius-m);
            max-height: 120px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .terminal-line {
            margin-bottom: 4px;
            line-height: 1.4;
        }

        .log-info {
            color: #4fc3f7;
        }

        .log-success {
            color: #66bb6a;
        }

        .log-error {
            color: #ef5350;
        }

        .log-warning {
            color: #ffa726;
        }

        /* Removed full-screen loading overlay - now using inline loading state */
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Utility classes */
        .mb-16 {
            margin-bottom: 16px;
        }

        .mt-16 {
            margin-top: 16px;
        }

        .flex-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Hide scrollbar but keep functionality */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-tertiary);
        }

        /* ========== Infinite Canvas Styles ========== */
        .canvas-viewport {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: radial-gradient(circle at 25% 25%, rgba(59, 130, 246, 0.05), transparent 28%),
                radial-gradient(circle at 75% 15%, rgba(59, 130, 246, 0.04), transparent 24%),
                #000000;
            cursor: grab;
        }

        .canvas-viewport.panning {
            cursor: grabbing;
        }

        .canvas-viewport.space-held {
            cursor: grab;
        }

        .canvas-content {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        .canvas-grid {
            position: absolute;
            width: 20000px;
            height: 20000px;
            left: -10000px;
            top: -10000px;
            background-image: radial-gradient(circle, rgba(255, 255, 255, 0.08) 1px, transparent 1px);
            background-size: 44px 44px;
            pointer-events: none;
            opacity: 0.35;
        }

        /* 画布标尺样式 */
        .canvas-ruler {
            position: absolute;
            background: var(--bg-secondary);
            z-index: 500;
            pointer-events: none;
        }

        .canvas-ruler-h {
            top: 0;
            left: 20px;
            right: 0;
            height: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .canvas-ruler-v {
            top: 20px;
            left: 0;
            bottom: 0;
            width: 20px;
            border-right: 1px solid var(--border-color);
        }

        .canvas-ruler-corner {
            position: absolute;
            top: 0;
            left: 0;
            width: 20px;
            height: 20px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
            z-index: 501;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .canvas-ruler-corner:hover {
            background: var(--bg-tertiary);
        }

        .ruler-tick {
            position: absolute;
            font-size: 9px;
            color: var(--text-tertiary);
            user-select: none;
        }

        .ruler-tick-h {
            bottom: 2px;
            transform: translateX(-50%);
        }

        .ruler-tick-v {
            right: 2px;
            transform: translateY(-50%);
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .ruler-tick-line-h {
            position: absolute;
            bottom: 0;
            width: 1px;
            background: var(--text-tertiary);
            transform: translateX(-50%);
        }

        .ruler-tick-line-v {
            position: absolute;
            right: 0;
            height: 1px;
            background: var(--text-tertiary);
            transform: translateY(-50%);
        }

        .draggable-node {
            position: absolute;
            left: 0;
            top: 0;
            background: transparent;
            border: none;
            border-radius: var(--radius-l);
            cursor: move;
            user-select: none;
            min-width: 0;
            will-change: transform;
            transition: box-shadow 0.2s ease;
        }

        .draggable-node.dragging {
            opacity: 0.95;
            z-index: 1000;
            transition: none;
        }

        .node-header {
            position: absolute;
            top: -44px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 14px;
            border-radius: 16px;
            border: 1px solid var(--border-color);
            background: rgba(20, 22, 30, 0.92);
            box-shadow: 0 14px 40px rgba(0, 0, 0, 0.45);
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            backdrop-filter: blur(8px);
            white-space: nowrap;
            opacity: 1;
            pointer-events: auto;
        }

        .draggable-node.node-batch .node-header {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%);
        }

        .node-header .ant-switch {
            background: var(--bg-tertiary);
        }

        .node-content {
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .node-content img {
            display: block;
            width: 100%;
            max-width: 100%;
            height: auto;
            object-fit: contain;
            border-radius: 0px;
            outline: 1px solid rgba(255, 255, 255, 0.14);
            outline-offset: 0;
            box-shadow: 0 18px 38px rgba(0, 0, 0, 0.65);
            transition: box-shadow 0.2s ease, transform 0.2s ease;
            -webkit-user-drag: none;
            user-drag: none;
            user-select: none;
            pointer-events: none;
        }

        .board-frame {
            width: 100%;
            border-radius: 0px;
            border: 1px dashed rgba(59, 130, 246, 0.6);
            background: rgba(59, 130, 246, 0.06);
            outline: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 18px 38px rgba(0, 0, 0, 0.55);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .board-hint {
            text-align: center;
            color: var(--text-secondary);
            padding: 16px;
            pointer-events: none;
        }

        .draggable-node.selected .board-frame {
            outline: 2px solid rgba(59, 130, 246, 0.75);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.18), 0 18px 38px rgba(0, 0, 0, 0.55);
        }

        .draggable-node:hover .node-content img {
            box-shadow: 0 22px 46px rgba(0, 0, 0, 0.75);
            transform: translateY(-2px);
        }

        .draggable-node.selected .node-content img {
            outline: 2px solid rgba(59, 130, 246, 0.75);
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.25), 0 20px 42px rgba(0, 0, 0, 0.65);
        }

        .zoom-controls {
            position: absolute;
            bottom: 18px;
            right: 18px;
            left: auto;
            transform: none;
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 16px;
            background: rgba(20, 24, 32, 0.92);
            border: 1px solid var(--border-color);
            border-radius: 999px;
            box-shadow: var(--shadow-sm);
            z-index: 100;
        }

        .zoom-controls button {
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .zoom-controls button:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .zoom-controls .zoom-value {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 50px;
            text-align: center;
        }

        /* Studio Left Dock (Lovart-like) */
        .studio-leftdock {
            position: absolute;
            left: 18px;
            top: 18px;
            z-index: 170;
            pointer-events: none;
        }

        .studio-leftdock .dock-surface {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            border-radius: 18px;
            background: rgba(14, 17, 23, 0.88);
            border: 1px solid rgba(59, 130, 246, 0.28);
            box-shadow: 0 18px 52px rgba(0, 0, 0, 0.75), inset 0 0 0 1px rgba(59, 130, 246, 0.08);
            backdrop-filter: blur(10px);
        }

        .studio-leftdock .dock-btn.ant-btn {
            width: 42px;
            height: 42px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .studio-leftdock .dock-btn.ant-btn:hover {
            background: rgba(59, 130, 246, 0.16);
            border-color: rgba(59, 130, 246, 0.35);
            color: var(--text-primary);
        }

        .studio-leftdock .dock-btn.ant-btn.active {
            background: rgba(59, 130, 246, 0.22);
            border-color: rgba(59, 130, 246, 0.55);
            color: #ffffff;
            box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.25);
        }

        .studio-leftdock .dock-sep {
            height: 1px;
            background: rgba(255, 255, 255, 0.08);
            margin: 2px 0;
        }

        .draggable-node .node-content .ant-upload {
            background: transparent !important;
            border: none !important;
        }

        /* Studio Command Bar */
        .studio-commandbar {
            position: absolute;
            left: 50%;
            bottom: 18px;
            transform: translateX(-50%);
            width: min(980px, calc(100% - 120px));
            z-index: 160;
            pointer-events: none;
        }

        .studio-commandbar.initial {
            bottom: 24px;
            transform: translateX(-50%);
            width: min(980px, calc(100% - 64px));
        }

        .studio-commandbar.initial .bar-surface {
            padding: 14px 16px;
            border-radius: 22px;
        }

        .studio-commandbar.initial .bar-input .ant-input {
            font-size: 16px;
        }

        .studio-commandbar .bar-surface {
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 18px;
            background: rgba(14, 17, 23, 0.88);
            border: 1px solid rgba(59, 130, 246, 0.28);
            box-shadow: 0 18px 52px rgba(0, 0, 0, 0.75), inset 0 0 0 1px rgba(59, 130, 246, 0.08);
            backdrop-filter: blur(10px);
        }

        .studio-commandbar.drag-active .bar-surface {
            border-color: var(--accent-color);
            box-shadow: var(--shadow-glow), 0 18px 52px rgba(0, 0, 0, 0.8);
        }

        .studio-commandbar .bar-actions {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 0 0 auto;
        }

        .studio-commandbar .bar-input {
            flex: 1;
            min-width: 240px;
        }

        .studio-commandbar .bar-input .ant-input,
        .studio-commandbar .bar-input .ant-input-textarea {
            font-size: 14px;
        }

        .studio-commandbar .bar-actions .ant-btn {
            height: 38px !important;
            border-radius: 999px !important;
        }

        .studio-commandbar .bar-actions .ant-btn:not(.ant-btn-primary) {
            width: 38px !important;
            padding: 0 !important;
        }

        .studio-commandbar .bar-actions .ant-btn-primary {
            padding: 0 18px !important;
        }

        .studio-commandbar .bar-surface .ant-select .ant-select-selector {
            height: 38px !important;
            border-radius: 999px !important;
            display: flex !important;
            align-items: center !important;
            background: rgba(255, 255, 255, 0.04) !important;
            border-color: rgba(255, 255, 255, 0.08) !important;
        }

        .studio-commandbar .bar-surface .ant-select .ant-select-selection-item {
            line-height: 38px !important;
            color: var(--text-secondary) !important;
        }

        .studio-commandbar .asset-indicators {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 4px 10px;
            justify-content: center;
            pointer-events: none;
        }

        .asset-chip {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 999px;
            background: rgba(20, 24, 32, 0.9);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            color: var(--text-secondary);
            font-size: 12px;
            pointer-events: auto;
            cursor: default;
        }

        .asset-chip .dot {
            width: 8px;
            height: 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.25);
        }

        .asset-chip.active {
            color: var(--text-primary);
            border-color: rgba(59, 130, 246, 0.45);
        }

        .asset-chip.active .dot {
            background: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }

        .marquee-rect {
            position: absolute;
            border: 1px dashed rgba(59, 130, 246, 0.9);
            background: rgba(59, 130, 246, 0.08);
            border-radius: 12px;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.12);
            pointer-events: none;
            z-index: 150;
        }

        .selection-toolbar {
            position: absolute;
            transform: translate(-50%, -100%);
            padding: 10px 12px;
            border-radius: 14px;
            background: rgba(20, 24, 32, 0.92);
            border: 1px solid rgba(59, 130, 246, 0.28);
            box-shadow: 0 18px 52px rgba(0, 0, 0, 0.65);
            backdrop-filter: blur(10px);
            z-index: 170;
        }

        .selection-toolbar .ant-btn {
            border-radius: 10px !important;
        }

        .annotation-dialog {
            z-index: 2000;
        }

        .control-section-title {
            font-size: 13px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 6px 0;
        }

        .control-chip {
            background: transparent;
            border: none;
            border-radius: 0;
            padding: 6px 0;
            box-shadow: none;
            width: 100%;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }

        .control-chip:last-child {
            border-bottom: none;
        }

        .control-chip .chip-label {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-bottom: 4px;
            display: block;
        }

        .control-chip .ant-segmented {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 4px 4px;
            padding: 0;
            background: transparent !important;
            border: none !important;
        }

        .control-chip .ant-segmented-item-label {
            font-size: 11px;
            letter-spacing: 0;
            white-space: nowrap;
            padding: 4px 8px;
        }

        .control-chip .ant-segmented-item {
            flex: 0 0 auto;
            min-width: 0;
            justify-content: center;
            overflow: visible;
            background: var(--bg-tertiary) !important;
            border-radius: 6px !important;
        }

        .control-chip .ant-segmented-item-selected {
            background: var(--accent-color) !important;
        }

        .ghost-drop {
            border: 1px dashed var(--border-color);
            border-radius: 0px;
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .pill-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 28px rgba(15, 23, 42, 0.12);
        }

        .resize-handle {
            position: absolute;
            right: 10px;
            bottom: 10px;
            width: 18px;
            height: 18px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid var(--border-color);
            cursor: nwse-resize;
            z-index: 12;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-tertiary);
            font-size: 12px;
        }

        .resize-handle:hover {
            background: rgba(59, 130, 246, 0.2);
            color: var(--accent-color);
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <!-- Removed full-screen loading overlay -->

    <!-- Shared JS Assets -->
    <script src="assets/js/api.js?v=7"></script>
    <script src="assets/js/main.js?v=7"></script>
    <script src="assets/js/tagging.js?v=7"></script>
    <script src="assets/js/chat.js?v=7"></script>
    <script src="assets/js/chat-history.js?v=7"></script>
    <script src="assets/js/canvas-annotate.js?v=7"></script>
    <script src="assets/js/task-queue.js?v=7"></script>

    <!-- Main React Application -->
    <script type="text/babel" data-type="module">
        const { useState, useEffect, useLayoutEffect, useRef, useCallback, useMemo } = React;
        const {
            Layout, Card, Button, Input, Upload, Segmented, Space, Badge, Drawer,
            FloatButton, Table, Progress, Modal, Tooltip, message, Switch, List, Tag, Avatar, Divider,
            Form, Select, Steps, Radio, Dropdown, InputNumber
        } = window.antd;
        const { Header, Content, Sider, Footer } = Layout;
        const { TextArea } = Input;
        const { Dragger } = Upload;

        // Ant Design Icons
        const icons = window.icons;
         const {
             PictureOutlined, SettingOutlined, HomeOutlined, RobotOutlined,
             ShoppingOutlined, ReloadOutlined, ControlOutlined, FileImageOutlined,
             ThunderboltOutlined, UnorderedListOutlined, EyeOutlined, BookOutlined,
             DeleteOutlined, SendOutlined, DownloadOutlined, BulbOutlined, ExperimentOutlined,
             GlobalOutlined, AppstoreOutlined, NumberOutlined, BgColorsOutlined, FireOutlined,
             FullscreenOutlined, PlusOutlined, CloseOutlined, BorderOutlined,
             CopyOutlined, ScissorOutlined, UndoOutlined, RedoOutlined,
             AlignLeftOutlined, AlignCenterOutlined, AlignRightOutlined,
             VerticalAlignTopOutlined, VerticalAlignMiddleOutlined, VerticalAlignBottomOutlined,
             LockOutlined, UnlockOutlined, ArrowUpOutlined, ArrowDownOutlined,
             DragOutlined, SelectOutlined, ZoomInOutlined, ZoomOutOutlined,
             ClearOutlined, FolderOpenOutlined, SaveOutlined, ColumnWidthOutlined,
             ColumnHeightOutlined, PicCenterOutlined, QuestionCircleOutlined,
             BorderOuterOutlined, GroupOutlined, UngroupOutlined, OrderedListOutlined
         } = icons;

        // Global state
        let singleRefFile = null;
        let singleProdFile = null;
        let singleResultData = null;

        // ========================================
        // Project Profile (品牌档案)
        // ========================================

        const PROJECT_PROFILE_KEY = 'xobi_project_profile_v1';

        function getDefaultProjectProfile() {
            return {
                version: 1,
                updated_at: Date.now(),
                project_name: '',
                primary_outputs: ['poster', 'banner', 'main'],
                default_language: 'zh',
                default_style_preset: 'generic',
                default_candidate_count: 4,
                brand_style_keywords: '高级、干净、商业质感、光影自然、不过度夸张',
                forbidden: '不要变形、不要偏色、不要新增Logo/水印/二维码；产品保持真实结构与质感',
                fidelity_level: 'strict' // strict | balanced
            };
        }

        function loadProjectProfile() {
            try {
                const raw = localStorage.getItem(PROJECT_PROFILE_KEY);
                if (!raw) return getDefaultProjectProfile();
                const parsed = JSON.parse(raw);
                if (!parsed || typeof parsed !== 'object') return getDefaultProjectProfile();
                return { ...getDefaultProjectProfile(), ...parsed, version: 1 };
            } catch {
                return getDefaultProjectProfile();
            }
        }

        function saveProjectProfile(profile) {
            try {
                localStorage.setItem(PROJECT_PROFILE_KEY, JSON.stringify(profile));
                return true;
            } catch {
                return false;
            }
        }

        function App() {
            // State management
            const [refImage, setRefImage] = useState(null);
            const [prodImage, setProdImage] = useState(null);
            const [resultImage, setResultImage] = useState(null);
            const [productName, setProductName] = useState('');
            const [customPrompt, setCustomPrompt] = useState('');
            const [quality, setQuality] = useState('1K');
             const [aspectRatio, setAspectRatio] = useState('auto');
             const [chatMessages, setChatMessages] = useState([
                 { role: 'ai', content: '你好！描述你想要的效果（可不上传图），点「生成」后我会用问答引导你出图。' }
             ]);
            const [inputValue, setInputValue] = useState('');
            const [isGenerating, setIsGenerating] = useState(false);
            const [isPreviewing, setIsPreviewing] = useState(false);
            const [historyVisible, setHistoryVisible] = useState(false);
            const [queueVisible, setQueueVisible] = useState(false);
            const [annotationMode, setAnnotationMode] = useState(false);
            const [refAnnotationMode, setRefAnnotationMode] = useState(false);
            const [prodAnnotationMode, setProdAnnotationMode] = useState(false);
            const [annotations, setAnnotations] = useState([]);
            const [previewVisible, setPreviewVisible] = useState(false);
            const [previewImage, setPreviewImage] = useState(null);
            const [queueTasks, setQueueTasks] = useState([]);

            // Studio workspace UI (Meitu tool-driven + Lovart chat-driven)
            const [aiPanelOpen, setAiPanelOpen] = useState(false);
            const [studioQuery, setStudioQuery] = useState('');
            const [studioDragActive, setStudioDragActive] = useState(false);
            const [stagedAssets, setStagedAssets] = useState([]); // assets uploaded before first generation
            const [prodAspect, setProdAspect] = useState(1);
            const [refAspect, setRefAspect] = useState(1);
            const stagedAssetsRef = useRef(stagedAssets);

            useEffect(() => {
                stagedAssetsRef.current = stagedAssets;
            }, [stagedAssets]);

            // Project Profile
            const [profileOpen, setProfileOpen] = useState(false);
            const [projectProfile, setProjectProfile] = useState(() => loadProjectProfile());
            const [profileForm] = Form.useForm();

            useEffect(() => {
                if (!profileOpen) return;
                try {
                    profileForm.setFieldsValue(projectProfile || getDefaultProjectProfile());
                } catch { }
            }, [profileOpen]);

             // ========================================
             // AI 引导生成（Lovart 式：问答 -> 计划/方向 -> 候选 -> 选中精修）
             // ========================================

              const [guidedStage, setGuidedStage] = useState('idle'); // idle | qa | plan | candidates
               const [guidedQuestionIndex, setGuidedQuestionIndex] = useState(0);
               const [guidedQuestions, setGuidedQuestions] = useState([]);
               const [guidedBrief, setGuidedBrief] = useState(null);
               const guidedBriefRef = useRef(guidedBrief);

              const [guidedLoadingPlan, setGuidedLoadingPlan] = useState(false);
              const [guidedGenerating, setGuidedGenerating] = useState(false);
              const [guidedPlan, setGuidedPlan] = useState(null);
              const [guidedDirections, setGuidedDirections] = useState([]);
              const guidedDirectionsRef = useRef(guidedDirections);

              useEffect(() => {
                  guidedBriefRef.current = guidedBrief;
              }, [guidedBrief]);

              useEffect(() => {
                  guidedDirectionsRef.current = guidedDirections || [];
              }, [guidedDirections]);
              const [guidedSelectedId, setGuidedSelectedId] = useState('A');
              const [guidedCandidates, setGuidedCandidates] = useState([]);

            // 新增高级控制选项
            const [imageLanguage, setImageLanguage] = useState('zh-CN');
            const [platform, setPlatform] = useState('通用');
            const [imageType, setImageType] = useState('商品主图');
            const [imageStyle, setImageStyle] = useState('自然');
            const [backgroundType, setBackgroundType] = useState('智能推荐');

            // ========== Infinite Canvas States ==========
            const [viewport, setViewport] = useState({ x: 0, y: 0, scale: 1 });
            // ========== 自动保存/恢复功能 ==========
            const AUTOSAVE_KEY = 'canvas_autosave_v1';
            const AUTOSAVE_INTERVAL = 30000; // 30秒自动保存

            const loadAutoSave = useCallback(() => {
                try {
                    const saved = localStorage.getItem(AUTOSAVE_KEY);
                    if (saved) {
                        const data = JSON.parse(saved);
                        if (data.nodes && Array.isArray(data.nodes) && data.nodes.length > 0) {
                            return data;
                        }
                    }
                } catch (e) {
                    console.warn('加载自动保存失败:', e);
                }
                return null;
            }, []);

            const saveToLocalStorage = useCallback(() => {
                try {
                    const currentNodes = nodesRef.current || [];
                    if (currentNodes.length === 0) return;

                    const data = {
                        nodes: currentNodes,
                        viewport: viewportRef.current,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(data));
                    console.log('[AutoSave] 已保存', currentNodes.length, '个节点');
                } catch (e) {
                    console.warn('自动保存失败:', e);
                }
            }, []);

            const clearAutoSave = useCallback(() => {
                localStorage.removeItem(AUTOSAVE_KEY);
            }, []);

            // 定时自动保存
            useEffect(() => {
                const interval = setInterval(saveToLocalStorage, AUTOSAVE_INTERVAL);
                return () => clearInterval(interval);
            }, [saveToLocalStorage]);

            // 页面关闭前保存
            useEffect(() => {
                const handleBeforeUnload = () => saveToLocalStorage();
                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [saveToLocalStorage]);

            // 启动时检查是否有自动保存
            useEffect(() => {
                const saved = loadAutoSave();
                if (saved && saved.nodes && saved.nodes.length > 0) {
                    const timeAgo = Math.round((Date.now() - saved.timestamp) / 60000);
                    Modal.confirm({
                        title: '发现自动保存的数据',
                        content: `检测到 ${timeAgo} 分钟前保存的 ${saved.nodes.length} 个节点。是否恢复？`,
                        okText: '恢复',
                        cancelText: '放弃',
                        onOk: () => {
                            setNodes(saved.nodes);
                            nodesRef.current = saved.nodes;
                            if (saved.viewport) {
                                setViewport(saved.viewport);
                                viewportRef.current = saved.viewport;
                            }
                            message.success('已恢复自动保存的数据');
                        },
                        onCancel: () => {
                            clearAutoSave();
                        }
                    });
                }
            }, []);

            const [nodes, setNodes] = useState([]);
            const [isPanning, setIsPanning] = useState(false);
            const [isDraggingNode, setIsDraggingNode] = useState(false);
            const [selectedNode, setSelectedNode] = useState(null);
            const [selectedNodeIds, setSelectedNodeIds] = useState([]);
            const [marquee, setMarquee] = useState(null); // { x1, y1, x2, y2 } in canvas px
            const [spaceHeld, setSpaceHeld] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });

            // ========== 历史记录系统 (撤销/重做) ==========
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [clipboard, setClipboard] = useState([]); // 剪贴板
            const [contextMenu, setContextMenu] = useState(null); // { x, y, nodeId }
            const [alignLines, setAlignLines] = useState({ h: [], v: [] }); // 对齐辅助线
            const [helpModalOpen, setHelpModalOpen] = useState(false); // 快捷键帮助
            const [minimapVisible, setMinimapVisible] = useState(true); // 小地图可见性
            const [gridSnapEnabled, setGridSnapEnabled] = useState(true); // 网格吸附
            const [lockedNodeIds, setLockedNodeIds] = useState([]); // 锁定的节点
            const [layerPanelOpen, setLayerPanelOpen] = useState(false); // 图层面板
            const [rulerVisible, setRulerVisible] = useState(true); // 标尺可见性
            const GRID_SIZE = 20; // 网格大小
            const RULER_SIZE = 20; // 标尺宽度
            const MAX_HISTORY = 50;

            const resizeRef = useRef(null);
            const canvasRef = useRef(null);
            const canvasContentRef = useRef(null);
            const viewportRef = useRef(viewport);
            const nodesRef = useRef(nodes);
            const nodeElsRef = useRef(new Map());
            const dragGroupRef = useRef(null);
            const nodesDirtyRef = useRef(false);
            const viewportDirtyRef = useRef(false);
            const wheelCommitTimerRef = useRef(null);
            const batchInputRef = useRef(null);
            const [layoutTick, setLayoutTick] = useState(0);
            const layoutRafRef = useRef(null);

            const applyViewportTransform = useCallback((v) => {
                const el = canvasContentRef.current;
                if (!el) return;
                const x = Number(v?.x || 0);
                const y = Number(v?.y || 0);
                const scale = Number(v?.scale || 1);
                el.style.transform = `translate3d(${x}px, ${y}px, 0) scale(${scale})`;
            }, []);

            useLayoutEffect(() => {
                viewportRef.current = viewport;
                applyViewportTransform(viewport);
            }, [viewport, applyViewportTransform]);

            useEffect(() => {
                nodesRef.current = nodes;
            }, [nodes]);

            // Keep DOM node positions in sync with state (position is driven by transform for performance)
            useLayoutEffect(() => {
                const map = nodeElsRef.current;
                if (!map) return;
                for (const node of (nodes || [])) {
                    const el = map.get(node.id);
                    if (!el) continue;
                    const x = Number(node?.x || 0);
                    const y = Number(node?.y || 0);
                    el.style.transform = `translate3d(${x}px, ${y}px, 0)`;
                }
            }, [nodes]);

            useEffect(() => {
                return () => {
                    if (wheelCommitTimerRef.current) {
                        clearTimeout(wheelCommitTimerRef.current);
                        wheelCommitTimerRef.current = null;
                    }
                    if (layoutRafRef.current) {
                        cancelAnimationFrame(layoutRafRef.current);
                        layoutRafRef.current = null;
                    }
                };
            }, []);

            const setNodeEl = useCallback((nodeId) => (el) => {
                const map = nodeElsRef.current;
                if (!map) return;
                if (el) map.set(nodeId, el);
                else map.delete(nodeId);
            }, []);

            const commitViewportFromRef = useCallback(() => {
                if (!viewportDirtyRef.current) return;
                viewportDirtyRef.current = false;
                const next = viewportRef.current || { x: 0, y: 0, scale: 1 };
                setViewport((prev) => {
                    if (!prev) return next;
                    return (prev.x === next.x && prev.y === next.y && prev.scale === next.scale) ? prev : next;
                });
            }, []);

            const setViewportNow = useCallback((next) => {
                if (!next) return;
                if (wheelCommitTimerRef.current) {
                    clearTimeout(wheelCommitTimerRef.current);
                    wheelCommitTimerRef.current = null;
                }
                viewportRef.current = next;
                viewportDirtyRef.current = false;
                applyViewportTransform(next);
                setViewport(next);
            }, [applyViewportTransform]);

            const commitNodesFromRef = useCallback(() => {
                if (!nodesDirtyRef.current) return;
                nodesDirtyRef.current = false;
                const list = nodesRef.current || [];
                setNodes(list.slice());
            }, []);

            const requestAutoLayout = useCallback(() => {
                if (layoutRafRef.current) return;
                layoutRafRef.current = requestAnimationFrame(() => {
                    layoutRafRef.current = null;
                    setLayoutTick(t => t + 1);
                });
            }, []);

            // Ensure initial layout (avoid first-open misalignment)
            useEffect(() => {
                requestAutoLayout();
            }, [requestAutoLayout]);

            const computeAutoLayout = useCallback((currentNodes) => {
                const canvasEl = canvasRef.current;
                if (!canvasEl) {
                    return { nodes: currentNodes, viewport: viewportRef.current || { x: 0, y: 0, scale: 1 } };
                }

                const rect = canvasEl.getBoundingClientRect();
                const canvasWidth = rect.width || 1;
                const canvasHeight = rect.height || 1;

                const outerPad = 80;
                const cellGap = 36;
                const rowGap = 80;
                const groupGap = 180;
                const maxCols = 6;
                const maxNodeHeight = Math.max(260, Math.floor(canvasHeight * 0.62));

                const groupOrder = [];
                const byGroup = new Map();
                currentNodes.forEach((node) => {
                    const groupId = node.groupId || 'default';
                    if (!byGroup.has(groupId)) {
                        byGroup.set(groupId, []);
                        groupOrder.push(groupId);
                    }
                    byGroup.get(groupId).push(node);
                });

                const layoutMap = new Map();
                let yCursor = outerPad;
                let minX = Infinity;
                let minY = Infinity;
                let maxX = -Infinity;
                let maxY = -Infinity;

                groupOrder.forEach((groupId) => {
                    const groupNodes = byGroup.get(groupId) || [];
                    if (groupNodes.length === 0) return;

                    const count = groupNodes.length;
                    const cols = Math.min(maxCols, count);
                    const rows = Math.ceil(count / cols);
                    const availableW = Math.max(240, canvasWidth - outerPad * 2 - cellGap * (cols - 1));
                    const cellWidth = availableW / cols;

                    const rowHeights = new Array(rows).fill(0);
                    const sized = groupNodes.map((node, idx) => {
                        const aspect = (node.aspect && isFinite(node.aspect) && node.aspect > 0) ? node.aspect : 1;
                        let width = cellWidth;
                        let height = width / aspect;
                        if (height > maxNodeHeight) {
                            height = maxNodeHeight;
                            width = Math.min(cellWidth, height * aspect);
                        }

                        const row = Math.floor(idx / cols);
                        rowHeights[row] = Math.max(rowHeights[row], height);
                        return { node, row, col: idx % cols, width, height };
                    });

                    const rowY = new Array(rows).fill(0);
                    for (let r = 0, y = yCursor; r < rows; r++) {
                        rowY[r] = y;
                        y += rowHeights[r] + rowGap;
                    }

                    const groupBottom = rowY[rows - 1] + rowHeights[rows - 1];
                    sized.forEach((entry) => {
                        const x = outerPad + entry.col * (cellWidth + cellGap) + (cellWidth - entry.width) / 2;
                        const y = rowY[entry.row];
                        layoutMap.set(entry.node.id, { ...entry.node, x, y, width: entry.width });

                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x + entry.width);
                        maxY = Math.max(maxY, y + entry.height);
                    });

                    yCursor = groupBottom + groupGap;
                });

                const laidOutNodes = currentNodes.map((node) => layoutMap.get(node.id) || node);

                if (!isFinite(minX) || !isFinite(maxX)) {
                    return { nodes: laidOutNodes, viewport: viewportRef.current || { x: 0, y: 0, scale: 1 } };
                }

                const contentW = maxX - minX;
                const contentH = maxY - minY;
                const fitPad = 80;

                let scale = (canvasWidth - fitPad * 2) / contentW;
                scale = Math.min(Math.max(scale, 0.12), 1.35);

                const centerX = minX + contentW / 2;
                const centerY = minY + contentH / 2;

                const viewportX = canvasWidth / 2 - centerX * scale;
                const viewportY = (contentH * scale <= canvasHeight - fitPad * 2)
                    ? (canvasHeight / 2 - centerY * scale)
                    : (fitPad - minY * scale);

                return { nodes: laidOutNodes, viewport: { x: viewportX, y: viewportY, scale } };
            }, []);

            useLayoutEffect(() => {
                const canvasEl = canvasRef.current;
                const rect = canvasEl?.getBoundingClientRect?.();
                if (!rect || rect.width < 50 || rect.height < 50) {
                    requestAutoLayout();
                    return;
                }

                const { nodes: laidOut, viewport: nextViewport } = computeAutoLayout(nodesRef.current || []);
                setNodes(laidOut);
                setViewport(nextViewport);
            }, [layoutTick, computeAutoLayout, requestAutoLayout]);

            useEffect(() => {
                let timer = null;
                const handleResize = () => {
                    if (timer) clearTimeout(timer);
                    timer = setTimeout(() => requestAutoLayout(), 100);
                };
                window.addEventListener('resize', handleResize);
                return () => {
                    window.removeEventListener('resize', handleResize);
                    if (timer) clearTimeout(timer);
                };
            }, [requestAutoLayout]);

            const handleNodeImageLoad = useCallback((nodeId) => (e) => {
                const img = e?.target;
                const w = img?.naturalWidth;
                const h = img?.naturalHeight;
                if (!w || !h) return;
                const aspect = w / h;
                setNodes(prev => prev.map(node => (node.id === nodeId ? { ...node, aspect } : node)));
                requestAutoLayout();
            }, [requestAutoLayout]);

            const readFileAsDataUrl = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error || new Error('Failed to read file'));
                reader.readAsDataURL(file);
            });

            const handleBatchImportClick = () => {
                batchInputRef.current?.click?.();
            };

            const handleBatchFiles = async (fileList) => {
                const files = Array.from(fileList || []).filter(Boolean);
                if (files.length === 0) return;
                const groupId = `batch-${Date.now()}`;
                try {
                    const items = await Promise.all(files.map(async (file, index) => {
                        const src = await readFileAsDataUrl(file);
                        const aspect = await getDataUrlAspect(src);
                        return {
                            id: `${groupId}-${index}`,
                            type: 'batch',
                            groupId,
                            src,
                            file,
                            x: 0,
                            y: 0,
                            width: 240,
                            aspect: aspect || 1
                        };
                    }));

                    const hasBoards = (nodesRef.current || []).length > 0;
                    if (!hasBoards) {
                        setStagedAssets(prev => [...prev, ...items]);
                        message.info(`已暂存 ${items.length} 张素材，生成后会自动进入画布`);
                        return;
                    }

                    setNodes(prev => [...prev, ...items]);
                    requestAutoLayout();
                } catch (err) {
                    message.error(`批量导入失败: ${err?.message || err}`);
                }
            };

            const handleBatchInputChange = (e) => {
                const files = e.target.files;
                if (files && files.length) {
                    handleStudioDropFiles(files);
                }
                e.target.value = '';
            };

            const handleClearBatch = () => {
                setNodes(prev => prev.filter(node => (node.groupId || 'top') === 'top'));
                requestAutoLayout();
            };

            // Refs
            const chatContainerRef = useRef(null);
            const annotatorRef = useRef(null);
            const refAnnotatorRef = useRef(null);
            const prodAnnotatorRef = useRef(null);

            // Initialize
            useEffect(() => {
                // Initialize tagging system
                if (typeof initTagging === 'function') {
                    setTimeout(initTagging, 500);
                }

                // Initialize task queue
                if (window.taskQueue) {
                    loadQueueTasks();
                }

                // Initialize canvas annotators for all three images
                if (typeof CanvasAnnotator !== 'undefined') {
                    // Result image annotator
                    annotatorRef.current = new CanvasAnnotator('single-result', {
                        onAnnotationAdd: (annotation) => console.log('[Result] Annotation added:', annotation),
                        onAnnotationUpdate: (annotation) => console.log('[Result] Annotation updated:', annotation),
                        onAnnotationDelete: (annotation) => console.log('[Result] Annotation deleted:', annotation)
                    });

                    // Reference image annotator
                    refAnnotatorRef.current = new CanvasAnnotator('ref-image-container', {
                        onAnnotationAdd: (annotation) => console.log('[Ref] Annotation added:', annotation),
                        onAnnotationUpdate: (annotation) => console.log('[Ref] Annotation updated:', annotation),
                        onAnnotationDelete: (annotation) => console.log('[Ref] Annotation deleted:', annotation)
                    });

                    // Product image annotator
                    prodAnnotatorRef.current = new CanvasAnnotator('prod-image-container', {
                        onAnnotationAdd: (annotation) => console.log('[Prod] Annotation added:', annotation),
                        onAnnotationUpdate: (annotation) => console.log('[Prod] Annotation updated:', annotation),
                        onAnnotationDelete: (annotation) => console.log('[Prod] Annotation deleted:', annotation)
                    });
                }

                log('info', '[System] 单图创作模式已就绪。Ctrl+点击元素可引用到聊天框。');
                setTimeout(() => requestAutoLayout(), 0);
            }, []);

            // Auto-scroll chat
            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [chatMessages]);

            // Load queue tasks
            const loadQueueTasks = () => {
                if (window.taskQueue) {
                    setQueueTasks([...window.taskQueue.queue]);
                }
            };

            // ========== Infinite Canvas Event Handlers ==========
            // Handle scroll wheel for zoom and pan
            const handleCanvasDragStart = useCallback((e) => {
                e.preventDefault();
                e.stopPropagation();
            }, []);

            const handleWheel = useCallback((e) => {
                e.preventDefault();
                const canvasEl = canvasRef.current;
                if (!canvasEl) return;

                const rect = canvasEl.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };

                if (e.ctrlKey || e.metaKey) {
                    // Zoom with Ctrl+Wheel
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    const newScale = Math.min(Math.max((v.scale || 1) * delta, 0.1), 3);

                    // Zoom towards mouse position
                    const scaleRatio = newScale / (v.scale || 1);
                    const newX = mouseX - (mouseX - (v.x || 0)) * scaleRatio;
                    const newY = mouseY - (mouseY - (v.y || 0)) * scaleRatio;

                    const next = { x: newX, y: newY, scale: newScale };
                    viewportRef.current = next;
                    viewportDirtyRef.current = true;
                    applyViewportTransform(next);
                } else {
                    // Pan with wheel
                    const panX = e.shiftKey ? -e.deltaY : -e.deltaX;
                    const panY = e.shiftKey ? 0 : -e.deltaY;
                    const next = { ...v, x: (v.x || 0) + panX, y: (v.y || 0) + panY };
                    viewportRef.current = next;
                    viewportDirtyRef.current = true;
                    applyViewportTransform(next);
                }

                if (wheelCommitTimerRef.current) clearTimeout(wheelCommitTimerRef.current);
                wheelCommitTimerRef.current = setTimeout(() => {
                    wheelCommitTimerRef.current = null;
                    commitViewportFromRef();
                }, 120);
            }, [applyViewportTransform, commitViewportFromRef]);

            // Selection helpers (marquee + multi-select)
            const clearCanvasSelection = useCallback(() => {
                setSelectedNode(null);
                setSelectedNodeIds([]);
            }, []);

            const setSingleSelection = useCallback((nodeId) => {
                setSelectedNode(nodeId || null);
                setSelectedNodeIds(nodeId ? [nodeId] : []);
            }, []);

            const toggleSelection = useCallback((nodeId) => {
                setSelectedNodeIds((prev) => {
                    const exists = prev.includes(nodeId);
                    const next = exists ? prev.filter((id) => id !== nodeId) : [...prev, nodeId];
                    setSelectedNode(next.length ? nodeId : null);
                    return next;
                });
            }, []);

            const getCanvasPoint = useCallback((e) => {
                const rect = canvasRef.current?.getBoundingClientRect?.();
                const left = rect?.left || 0;
                const top = rect?.top || 0;
                return { x: e.clientX - left, y: e.clientY - top };
            }, []);

            const getNodeWorldBounds = useCallback((node) => {
                const aspect = (node.aspect && isFinite(node.aspect) && node.aspect > 0) ? node.aspect : 1;
                const width = Number(node.width || 0);
                const height = width / aspect;
                return { x1: node.x, y1: node.y, x2: node.x + width, y2: node.y + height };
            }, []);

            const computeMarqueeSelection = useCallback((m) => {
                if (!m) return [];
                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                const scale = v.scale || 1;
                const x1 = (Math.min(m.x1, m.x2) - v.x) / scale;
                const y1 = (Math.min(m.y1, m.y2) - v.y) / scale;
                const x2 = (Math.max(m.x1, m.x2) - v.x) / scale;
                const y2 = (Math.max(m.y1, m.y2) - v.y) / scale;

                const ids = [];
                const list = nodesRef.current || [];
                for (const node of list) {
                    const b = getNodeWorldBounds(node);
                    const intersects = b.x2 >= x1 && b.x1 <= x2 && b.y2 >= y1 && b.y1 <= y2;
                    if (intersects) ids.push(node.id);
                }
                return ids;
            }, [getNodeWorldBounds]);

            // Canvas mouse events for panning
            const handleCanvasMouseDown = useCallback((e) => {
                // 空格键拖拽、鼠标中键拖拽、或鼠标右键拖拽（非右键菜单时）
                if (spaceHeld || e.button === 1 || e.button === 2) {
                    // 右键点击时，如果按下了Ctrl/Shift，不进入拖拽模式，让右键菜单处理
                    if (e.button === 2 && (e.ctrlKey || e.shiftKey)) {
                        return;
                    }
                    setIsPanning(true);
                    const v = viewportRef.current || viewport;
                    setDragStart({ x: e.clientX - (v?.x || 0), y: e.clientY - (v?.y || 0) });
                    e.preventDefault();
                } else if (e.button === 0 && (e.target === canvasRef.current || e.target.classList.contains('canvas-grid'))) {
                    const pt = getCanvasPoint(e);
                    setMarquee({ x1: pt.x, y1: pt.y, x2: pt.x, y2: pt.y });
                    clearCanvasSelection();
                    e.preventDefault();
                }
            }, [spaceHeld, clearCanvasSelection, getCanvasPoint, viewport]);

            const handleCanvasMouseMove = useCallback((e) => {
                if (isPanning) {
                    const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                    const next = { ...v, x: e.clientX - dragStart.x, y: e.clientY - dragStart.y };
                    viewportRef.current = next;
                    viewportDirtyRef.current = true;
                    applyViewportTransform(next);
                } else if (marquee) {
                    const pt = getCanvasPoint(e);
                    const next = { ...marquee, x2: pt.x, y2: pt.y };
                    setMarquee(next);
                    const ids = computeMarqueeSelection(next);
                    setSelectedNodeIds(ids);
                    setSelectedNode(ids[0] || null);
                }
            }, [isPanning, dragStart, marquee, getCanvasPoint, computeMarqueeSelection, applyViewportTransform]);

            const handleCanvasMouseUp = useCallback(() => {
                setIsPanning(false);
                setIsDraggingNode(false);
                dragGroupRef.current = null;
                commitViewportFromRef();
                commitNodesFromRef();
                if (marquee) {
                    const dx = Math.abs(marquee.x2 - marquee.x1);
                    const dy = Math.abs(marquee.y2 - marquee.y1);
                    if (dx < 6 && dy < 6) {
                        clearCanvasSelection();
                    }
                    setMarquee(null);
                }
            }, [marquee, clearCanvasSelection, commitViewportFromRef, commitNodesFromRef]);

            // Node drag handlers
            const handleNodeMouseDown = useCallback((e, nodeId) => {
                if (spaceHeld) return;
                e.stopPropagation();

                // 检查节点是否被锁定
                if (lockedNodeIds.includes(nodeId)) {
                    message.warning('此节点已锁定，按 Ctrl+L 解锁');
                    return;
                }

                if (e.shiftKey) {
                    toggleSelection(nodeId);
                    return;
                }
                setMarquee(null);

                const isMulti = selectedNodeIds.includes(nodeId) && selectedNodeIds.length > 1;
                if (!isMulti) {
                    setSingleSelection(nodeId);
                } else {
                    setSelectedNode(nodeId);
                }

                // 过滤掉锁定的节点
                const idsToMove = isMulti
                    ? selectedNodeIds.filter(id => !lockedNodeIds.includes(id))
                    : (lockedNodeIds.includes(nodeId) ? [] : [nodeId]);

                if (idsToMove.length === 0) {
                    message.warning('所有选中节点都已锁定');
                    return;
                }

                setIsDraggingNode(true);

                // Clone nodes for interaction (avoid mutating React state objects during drag)
                const baseNodes = nodesRef.current || [];
                const cloned = baseNodes.map((n) => ({ ...n }));
                nodesRef.current = cloned;

                const nodeMap = new Map(cloned.map((n) => [n.id, n]));
                const items = idsToMove.map((id) => {
                    const node = nodeMap.get(id);
                    if (!node) return null;
                    return { id, node, startX: Number(node.x || 0), startY: Number(node.y || 0) };
                }).filter(Boolean);

                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                const scale = v.scale || 1;
                dragGroupRef.current = {
                    startMouseX: e.clientX / scale,
                    startMouseY: e.clientY / scale,
                    items
                };
            }, [spaceHeld, setSingleSelection, toggleSelection, selectedNodeIds, lockedNodeIds]);

            const handleNodeMouseMove = useCallback((e) => {
                if (!isDraggingNode || isPanning || e.buttons !== 1) return;
                const group = dragGroupRef.current;
                if (!group || !(group.items || []).length) return;

                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                const scale = v.scale || 1;
                const mouseX = e.clientX / scale;
                const mouseY = e.clientY / scale;
                const dx = mouseX - (group.startMouseX || 0);
                const dy = mouseY - (group.startMouseY || 0);

                // 计算拖拽节点的边界
                const draggedIds = new Set(group.items.map(item => item.id));
                const SNAP_THRESHOLD = 8; // 吸附阈值（像素）
                let snapDx = 0, snapDy = 0;
                const newAlignLines = { h: [], v: [] };

                // 获取所有未被拖拽的节点
                const otherNodes = (nodesRef.current || []).filter(n => !draggedIds.has(n.id));

                if (otherNodes.length > 0) {
                    // 计算拖拽组的边界
                    let dragMinX = Infinity, dragMaxX = -Infinity;
                    let dragMinY = Infinity, dragMaxY = -Infinity;

                    for (const item of group.items) {
                        const nx = (item.startX || 0) + dx;
                        const ny = (item.startY || 0) + dy;
                        const nw = item.node.width || 200;
                        const aspect = (item.node.aspect && isFinite(item.node.aspect) && item.node.aspect > 0) ? item.node.aspect : 1;
                        const nh = nw / aspect;

                        dragMinX = Math.min(dragMinX, nx);
                        dragMaxX = Math.max(dragMaxX, nx + nw);
                        dragMinY = Math.min(dragMinY, ny);
                        dragMaxY = Math.max(dragMaxY, ny + nh);
                    }

                    const dragCenterX = (dragMinX + dragMaxX) / 2;
                    const dragCenterY = (dragMinY + dragMaxY) / 2;

                    // 检查与其他节点的对齐
                    for (const other of otherNodes) {
                        const ox = other.x || 0;
                        const ow = other.width || 200;
                        const aspect = (other.aspect && isFinite(other.aspect) && other.aspect > 0) ? other.aspect : 1;
                        const oh = ow / aspect;
                        const oy = other.y || 0;
                        const oCenterX = ox + ow / 2;
                        const oCenterY = oy + oh / 2;

                        // 左边对齐
                        if (Math.abs(dragMinX - ox) < SNAP_THRESHOLD) {
                            snapDx = ox - dragMinX;
                            newAlignLines.v.push(ox);
                        }
                        // 右边对齐
                        if (Math.abs(dragMaxX - (ox + ow)) < SNAP_THRESHOLD) {
                            snapDx = (ox + ow) - dragMaxX;
                            newAlignLines.v.push(ox + ow);
                        }
                        // 左对右
                        if (Math.abs(dragMinX - (ox + ow)) < SNAP_THRESHOLD) {
                            snapDx = (ox + ow) - dragMinX;
                            newAlignLines.v.push(ox + ow);
                        }
                        // 右对左
                        if (Math.abs(dragMaxX - ox) < SNAP_THRESHOLD) {
                            snapDx = ox - dragMaxX;
                            newAlignLines.v.push(ox);
                        }
                        // 水平中心对齐
                        if (Math.abs(dragCenterX - oCenterX) < SNAP_THRESHOLD) {
                            snapDx = oCenterX - dragCenterX;
                            newAlignLines.v.push(oCenterX);
                        }

                        // 顶边对齐
                        if (Math.abs(dragMinY - oy) < SNAP_THRESHOLD) {
                            snapDy = oy - dragMinY;
                            newAlignLines.h.push(oy);
                        }
                        // 底边对齐
                        if (Math.abs(dragMaxY - (oy + oh)) < SNAP_THRESHOLD) {
                            snapDy = (oy + oh) - dragMaxY;
                            newAlignLines.h.push(oy + oh);
                        }
                        // 顶对底
                        if (Math.abs(dragMinY - (oy + oh)) < SNAP_THRESHOLD) {
                            snapDy = (oy + oh) - dragMinY;
                            newAlignLines.h.push(oy + oh);
                        }
                        // 底对顶
                        if (Math.abs(dragMaxY - oy) < SNAP_THRESHOLD) {
                            snapDy = oy - dragMaxY;
                            newAlignLines.h.push(oy);
                        }
                        // 垂直中心对齐
                        if (Math.abs(dragCenterY - oCenterY) < SNAP_THRESHOLD) {
                            snapDy = oCenterY - dragCenterY;
                            newAlignLines.h.push(oCenterY);
                        }
                    }
                }

                // 去重辅助线
                newAlignLines.h = [...new Set(newAlignLines.h)];
                newAlignLines.v = [...new Set(newAlignLines.v)];
                setAlignLines(newAlignLines);

                // 应用位置（带吸附）
                for (const item of group.items) {
                    const nx = (item.startX || 0) + dx + snapDx;
                    const ny = (item.startY || 0) + dy + snapDy;
                    item.node.x = nx;
                    item.node.y = ny;
                    const el = nodeElsRef.current?.get?.(item.id);
                    if (el) el.style.transform = `translate3d(${nx}px, ${ny}px, 0)`;
                }
                nodesDirtyRef.current = true;
            }, [isDraggingNode, isPanning]);

            const handleNodeMouseUp = useCallback(() => {
                setIsDraggingNode(false);
                dragGroupRef.current = null;
                setAlignLines({ h: [], v: [] }); // 清除辅助线
                commitNodesFromRef();
            }, [commitNodesFromRef]);

            // ========== 双击查看大图 ==========
            const handleNodeDoubleClick = useCallback((e, nodeId) => {
                e.stopPropagation();
                const node = (nodesRef.current || []).find(n => n.id === nodeId);
                if (!node) return;

                // 获取节点的图片源
                let imageSrc = null;
                if (node.type === 'product' && prodImage) {
                    imageSrc = prodImage;
                } else if (node.type === 'reference' && refImage) {
                    imageSrc = refImage;
                } else if (node.type === 'result' && resultImage) {
                    imageSrc = resultImage;
                } else if (node.src) {
                    imageSrc = node.src;
                }

                if (imageSrc) {
                    setPreviewImage({
                        src: imageSrc,
                        title: node.fileName || node.type || '图片预览'
                    });
                }
            }, [prodImage, refImage, resultImage]);

            // ========== 快捷键帮助数据 ==========
            const shortcutHelpData = useMemo(() => [
                { category: '基本操作', shortcuts: [
                    { key: 'Delete / Backspace', desc: '删除选中节点' },
                    { key: 'Ctrl + Z', desc: '撤销' },
                    { key: 'Ctrl + Y / Ctrl+Shift+Z', desc: '重做' },
                    { key: 'Ctrl + C', desc: '复制选中节点' },
                    { key: 'Ctrl + V', desc: '粘贴' },
                    { key: 'Ctrl + A', desc: '全选' },
                    { key: 'Esc', desc: '取消选择' },
                ]},
                { category: '画布导航', shortcuts: [
                    { key: '空格 + 拖拽', desc: '平移画布' },
                    { key: '鼠标中键拖拽', desc: '平移画布' },
                    { key: 'Ctrl + 滚轮', desc: '缩放画布' },
                    { key: '双击节点', desc: '查看大图' },
                ]},
                { category: '节点调整', shortcuts: [
                    { key: '方向键', desc: '微调节点位置 (1px)' },
                    { key: 'Shift + 方向键', desc: '快速微调 (10px)' },
                    { key: '右键点击', desc: '打开上下文菜单' },
                    { key: '拖拽边角', desc: '调整节点大小' },
                ]},
                { category: '其他', shortcuts: [
                    { key: '? / F1', desc: '显示此帮助' },
                    { key: '拖拽文件到画布', desc: '导入图片' },
                ]}
            ], []);

            // ========== 小地图计算 ==========
            const minimapData = useMemo(() => {
                const currentNodes = nodes || [];
                if (currentNodes.length === 0) return null;

                // 计算所有节点的边界
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                currentNodes.forEach(n => {
                    const x = n.x || 0;
                    const y = n.y || 0;
                    const w = n.width || 200;
                    const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                    const h = w / aspect;
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x + w);
                    maxY = Math.max(maxY, y + h);
                });

                const contentWidth = maxX - minX;
                const contentHeight = maxY - minY;

                if (contentWidth <= 0 || contentHeight <= 0) return null;

                const MINIMAP_WIDTH = 150;
                const MINIMAP_HEIGHT = 100;
                const scale = Math.min(MINIMAP_WIDTH / contentWidth, MINIMAP_HEIGHT / contentHeight, 0.1);

                return {
                    minX, minY, maxX, maxY,
                    contentWidth, contentHeight,
                    scale,
                    width: MINIMAP_WIDTH,
                    height: Math.min(MINIMAP_HEIGHT, contentHeight * scale),
                    nodes: currentNodes.map(n => {
                        const x = n.x || 0;
                        const y = n.y || 0;
                        const w = n.width || 200;
                        const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                        const h = w / aspect;
                        return {
                            id: n.id,
                            x: (x - minX) * scale,
                            y: (y - minY) * scale,
                            w: w * scale,
                            h: h * scale,
                            type: n.type
                        };
                    })
                };
            }, [nodes]);

            // ========== 标尺刻度计算 ==========
            const rulerTicks = useMemo(() => {
                if (!canvasRef.current) return { horizontal: [], vertical: [] };
                const canvasRect = canvasRef.current.getBoundingClientRect();
                const width = canvasRect.width || 1200;
                const height = canvasRect.height || 800;
                const scale = viewport.scale || 1;
                const offsetX = viewport.x || 0;
                const offsetY = viewport.y || 0;

                // 根据缩放级别选择合适的刻度间隔
                let baseInterval = 100;
                if (scale < 0.25) baseInterval = 500;
                else if (scale < 0.5) baseInterval = 200;
                else if (scale >= 2) baseInterval = 50;

                // 计算画布坐标范围
                const startX = Math.floor(-offsetX / scale / baseInterval) * baseInterval;
                const endX = Math.ceil((width - offsetX) / scale / baseInterval) * baseInterval;
                const startY = Math.floor(-offsetY / scale / baseInterval) * baseInterval;
                const endY = Math.ceil((height - offsetY) / scale / baseInterval) * baseInterval;

                const horizontal = [];
                const vertical = [];

                for (let x = startX; x <= endX; x += baseInterval) {
                    const screenX = x * scale + offsetX;
                    if (screenX >= RULER_SIZE && screenX <= width) {
                        horizontal.push({ pos: screenX, label: x, major: x % (baseInterval * 5) === 0 });
                    }
                }

                for (let y = startY; y <= endY; y += baseInterval) {
                    const screenY = y * scale + offsetY;
                    if (screenY >= RULER_SIZE && screenY <= height) {
                        vertical.push({ pos: screenY, label: y, major: y % (baseInterval * 5) === 0 });
                    }
                }

                return { horizontal, vertical };
            }, [viewport.x, viewport.y, viewport.scale, layoutTick]);

            const handleMinimapClick = useCallback((e) => {
                if (!minimapData || !canvasRef.current) return;
                const rect = e.currentTarget.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // 转换为画布坐标
                const canvasX = minimapData.minX + clickX / minimapData.scale;
                const canvasY = minimapData.minY + clickY / minimapData.scale;

                // 计算视口位置（使点击位置居中）
                const canvasRect = canvasRef.current.getBoundingClientRect();
                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                const newX = canvasRect.width / 2 - canvasX * v.scale;
                const newY = canvasRect.height / 2 - canvasY * v.scale;

                setViewportNow({ ...v, x: newX, y: newY });
            }, [minimapData, setViewportNow]);

            // ========== 节点锁定功能 ==========
            const handleLockNodes = useCallback(() => {
                if (selectedNodeIds.length === 0) {
                    message.warning('请先选中要锁定的节点');
                    return;
                }
                setLockedNodeIds(prev => {
                    const newLocked = [...new Set([...prev, ...selectedNodeIds])];
                    message.success(`已锁定 ${selectedNodeIds.length} 个节点`);
                    return newLocked;
                });
            }, [selectedNodeIds]);

            const handleUnlockNodes = useCallback(() => {
                if (selectedNodeIds.length === 0) {
                    message.warning('请先选中要解锁的节点');
                    return;
                }
                setLockedNodeIds(prev => {
                    const unlockSet = new Set(selectedNodeIds);
                    const newLocked = prev.filter(id => !unlockSet.has(id));
                    message.success(`已解锁 ${selectedNodeIds.length} 个节点`);
                    return newLocked;
                });
            }, [selectedNodeIds]);

            const handleToggleLock = useCallback(() => {
                if (selectedNodeIds.length === 0) return;
                const allLocked = selectedNodeIds.every(id => lockedNodeIds.includes(id));
                if (allLocked) {
                    handleUnlockNodes();
                } else {
                    handleLockNodes();
                }
            }, [selectedNodeIds, lockedNodeIds, handleLockNodes, handleUnlockNodes]);

            // ========== 网格吸附 ==========
            const snapToGrid = useCallback((value) => {
                if (!gridSnapEnabled) return value;
                return Math.round(value / GRID_SIZE) * GRID_SIZE;
            }, [gridSnapEnabled]);

            // ========== 节点分组 (Ctrl+G) ==========
            const handleGroupNodes = useCallback(() => {
                if (selectedNodeIds.length < 2) {
                    message.warning('请至少选中 2 个节点才能编组');
                    return;
                }
                pushHistory(nodesRef.current);
                const groupId = `group-${Date.now()}`;
                setNodes(prev => prev.map(n => {
                    if (selectedNodeIds.includes(n.id)) {
                        return { ...n, groupId };
                    }
                    return n;
                }));
                message.success(`已将 ${selectedNodeIds.length} 个节点编组`);
            }, [selectedNodeIds, pushHistory]);

            const handleUngroupNodes = useCallback(() => {
                if (selectedNodeIds.length === 0) return;
                pushHistory(nodesRef.current);
                setNodes(prev => prev.map(n => {
                    if (selectedNodeIds.includes(n.id)) {
                        const { groupId, ...rest } = n;
                        return rest;
                    }
                    return n;
                }));
                message.success('已解除编组');
            }, [selectedNodeIds, pushHistory]);

            // ========== 批量调整大小 ==========
            const handleBatchResize = useCallback((newWidth) => {
                if (selectedNodeIds.length === 0) return;
                pushHistory(nodesRef.current);
                setNodes(prev => prev.map(n => {
                    if (selectedNodeIds.includes(n.id)) {
                        return { ...n, width: newWidth };
                    }
                    return n;
                }));
                message.success(`已调整 ${selectedNodeIds.length} 个节点大小`);
            }, [selectedNodeIds, pushHistory]);

            const handleResizeMouseDown = (e, nodeId) => {
                e.stopPropagation();

                const baseNodes = nodesRef.current || [];
                const cloned = baseNodes.map((n) => ({ ...n }));
                nodesRef.current = cloned;

                const node = cloned.find(n => n.id === nodeId);
                if (!node) return;
                resizeRef.current = {
                    nodeId,
                    node,
                    startX: e.clientX,
                    startWidth: node.width
                };
                setSelectedNode(nodeId);
                setSelectedNodeIds([nodeId]);
            };

            useEffect(() => {
                const handleResizeMouseMove = (e) => {
                    const data = resizeRef.current;
                    if (!data) return;
                    const scale = viewportRef.current?.scale || 1;
                    const delta = (e.clientX - data.startX) / scale;
                    const width = Math.min(800, Math.max(200, data.startWidth + delta));
                    if (data.node) data.node.width = width;
                    const el = nodeElsRef.current?.get?.(data.nodeId);
                    if (el) el.style.width = `${width}px`;
                    nodesDirtyRef.current = true;
                    e.preventDefault();
                };

                const handleResizeMouseUp = () => {
                    resizeRef.current = null;
                    commitNodesFromRef();
                };

                document.addEventListener('mousemove', handleResizeMouseMove);
                document.addEventListener('mouseup', handleResizeMouseUp);
                return () => {
                    document.removeEventListener('mousemove', handleResizeMouseMove);
                    document.removeEventListener('mouseup', handleResizeMouseUp);
                };
            }, [commitNodesFromRef]);

            const handleNodeWheel = useCallback((e, nodeId) => {
                if (e.ctrlKey || e.metaKey) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? -20 : 20;
                setNodes(prev => prev.map(node => {
                    if (node.id === nodeId) {
                        const width = Math.min(800, Math.max(200, node.width + delta));
                        return { ...node, width };
                    }
                    return node;
                }));
            }, []);
            // Keyboard events for space key panning and shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    // 忽略输入框中的按键
                    const tag = e.target?.tagName?.toLowerCase();
                    const isInput = tag === 'input' || tag === 'textarea' || e.target?.isContentEditable;

                    if (e.code === 'Space' && !e.repeat && !isInput) {
                        setSpaceHeld(true);
                        e.preventDefault();
                    }

                    // Delete / Backspace 删除节点
                    if ((e.key === 'Delete' || e.key === 'Backspace') && !isInput) {
                        e.preventDefault();
                        handleDeleteNodes();
                    }

                    // Ctrl+Z 撤销
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                        e.preventDefault();
                        handleUndo();
                    }

                    // Ctrl+Y 或 Ctrl+Shift+Z 重做
                    if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                        e.preventDefault();
                        handleRedo();
                    }

                    // Ctrl+C 复制
                    if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !isInput) {
                        e.preventDefault();
                        handleCopy();
                    }

                    // Ctrl+V 粘贴
                    if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !isInput) {
                        e.preventDefault();
                        handlePaste();
                    }

                    // Ctrl+A 全选
                    if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !isInput) {
                        e.preventDefault();
                        const allIds = (nodesRef.current || []).map(n => n.id);
                        setSelectedNodeIds(allIds);
                        if (allIds.length > 0) setSelectedNode(allIds[0]);
                        message.success(`已选中 ${allIds.length} 个节点`);
                    }

                    // Escape 取消选择
                    if (e.key === 'Escape') {
                        setSelectedNodeIds([]);
                        setSelectedNode(null);
                        closeContextMenu();
                        setPreviewImage(null); // 关闭预览
                    }

                    // ? 或 F1 显示快捷键帮助
                    if ((e.key === '?' || e.key === 'F1') && !isInput) {
                        e.preventDefault();
                        setHelpModalOpen(true);
                    }

                    // Ctrl+G 编组
                    if ((e.ctrlKey || e.metaKey) && e.key === 'g' && !e.shiftKey && !isInput) {
                        e.preventDefault();
                        handleGroupNodes();
                    }

                    // Ctrl+Shift+G 解除编组
                    if ((e.ctrlKey || e.metaKey) && e.key === 'g' && e.shiftKey && !isInput) {
                        e.preventDefault();
                        handleUngroupNodes();
                    }

                    // Ctrl+L 锁定/解锁
                    if ((e.ctrlKey || e.metaKey) && e.key === 'l' && !isInput) {
                        e.preventDefault();
                        handleToggleLock();
                    }

                    // 方向键微调 (带 Shift 加速)
                    if (!isInput && selectedNodeIds.length > 0) {
                        const step = e.shiftKey ? 10 : 1;
                        switch (e.key) {
                            case 'ArrowUp':
                                e.preventDefault();
                                handleNudge(0, -step);
                                break;
                            case 'ArrowDown':
                                e.preventDefault();
                                handleNudge(0, step);
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                handleNudge(-step, 0);
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                handleNudge(step, 0);
                                break;
                        }
                    }
                };
                const handleKeyUp = (e) => {
                    if (e.code === 'Space') {
                        setSpaceHeld(false);
                        setIsPanning(false);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [handleDeleteNodes, handleUndo, handleRedo, handleCopy, handlePaste, handleNudge, selectedNodeIds, closeContextMenu]);

            // Global mouseup guard to avoid stuck dragging/panning
            useEffect(() => {
                const handleGlobalMouseUp = () => {
                    setIsPanning(false);
                    setIsDraggingNode(false);
                    dragGroupRef.current = null;
                    commitViewportFromRef();
                    commitNodesFromRef();
                };
                window.addEventListener('mouseup', handleGlobalMouseUp);
                return () => window.removeEventListener('mouseup', handleGlobalMouseUp);
            }, [commitViewportFromRef, commitNodesFromRef]);

            // Zoom controls
            const handleZoomIn = () => {
                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                setViewportNow({ ...v, scale: Math.min((v.scale || 1) * 1.2, 3) });
            };
            const handleZoomOut = () => {
                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                setViewportNow({ ...v, scale: Math.max((v.scale || 1) / 1.2, 0.1) });
            };
            const handleZoomReset = () => setViewportNow({ x: 0, y: 0, scale: 1 });
            const handleFitView = () => requestAutoLayout();

            // ========== 历史记录功能 ==========
            const pushHistory = useCallback((newNodes) => {
                const snapshot = JSON.parse(JSON.stringify(newNodes));
                setHistory(prev => {
                    const newHistory = prev.slice(0, historyIndex + 1);
                    newHistory.push(snapshot);
                    if (newHistory.length > MAX_HISTORY) newHistory.shift();
                    return newHistory;
                });
                setHistoryIndex(prev => Math.min(prev + 1, MAX_HISTORY - 1));
            }, [historyIndex]);

            const handleUndo = useCallback(() => {
                if (historyIndex <= 0) {
                    message.info('没有可撤销的操作');
                    return;
                }
                const prevIndex = historyIndex - 1;
                const prevState = history[prevIndex];
                if (prevState) {
                    setNodes(prevState);
                    nodesRef.current = prevState;
                    setHistoryIndex(prevIndex);
                    message.success('已撤销');
                }
            }, [history, historyIndex]);

            const handleRedo = useCallback(() => {
                if (historyIndex >= history.length - 1) {
                    message.info('没有可重做的操作');
                    return;
                }
                const nextIndex = historyIndex + 1;
                const nextState = history[nextIndex];
                if (nextState) {
                    setNodes(nextState);
                    nodesRef.current = nextState;
                    setHistoryIndex(nextIndex);
                    message.success('已重做');
                }
            }, [history, historyIndex]);

            // ========== 删除节点 ==========
            const handleDeleteNodes = useCallback((nodeIds) => {
                const ids = nodeIds || selectedNodeIds;
                if (!ids || ids.length === 0) {
                    message.warning('请先选中要删除的节点');
                    return;
                }
                // 保护特殊节点
                const protectedIds = ['prod', 'ref', 'result'];
                const toDelete = ids.filter(id => !protectedIds.includes(id));
                const protectedCount = ids.length - toDelete.length;

                if (toDelete.length === 0) {
                    message.warning('产品图、参考图、结果图不能删除');
                    return;
                }

                pushHistory(nodesRef.current);
                setNodes(prev => prev.filter(n => !toDelete.includes(n.id)));
                setSelectedNodeIds([]);
                setSelectedNode(null);

                if (protectedCount > 0) {
                    message.success(`已删除 ${toDelete.length} 个节点 (${protectedCount} 个受保护节点已跳过)`);
                } else {
                    message.success(`已删除 ${toDelete.length} 个节点`);
                }
                requestAutoLayout();
            }, [selectedNodeIds, pushHistory, requestAutoLayout]);

            // ========== 复制/粘贴 ==========
            const handleCopy = useCallback(() => {
                if (selectedNodeIds.length === 0) {
                    message.warning('请先选中要复制的节点');
                    return;
                }
                const nodesToCopy = (nodesRef.current || []).filter(n => selectedNodeIds.includes(n.id));
                setClipboard(JSON.parse(JSON.stringify(nodesToCopy)));
                message.success(`已复制 ${nodesToCopy.length} 个节点`);
            }, [selectedNodeIds]);

            const handlePaste = useCallback(() => {
                if (clipboard.length === 0) {
                    message.warning('剪贴板为空');
                    return;
                }
                pushHistory(nodesRef.current);
                const offset = 50;
                const newNodes = clipboard.map((n, i) => ({
                    ...n,
                    id: `paste-${Date.now()}-${i}`,
                    x: (n.x || 0) + offset,
                    y: (n.y || 0) + offset
                }));
                setNodes(prev => [...prev, ...newNodes]);
                setSelectedNodeIds(newNodes.map(n => n.id));
                setSelectedNode(newNodes[0]?.id || null);
                message.success(`已粘贴 ${newNodes.length} 个节点`);
            }, [clipboard, pushHistory]);

            // ========== 键盘微调 ==========
            const handleNudge = useCallback((dx, dy) => {
                if (selectedNodeIds.length === 0) return;
                setNodes(prev => prev.map(n => {
                    if (selectedNodeIds.includes(n.id)) {
                        return { ...n, x: (n.x || 0) + dx, y: (n.y || 0) + dy };
                    }
                    return n;
                }));
            }, [selectedNodeIds]);

            // ========== 多选对齐 ==========
            const handleAlign = useCallback((type) => {
                if (selectedNodeIds.length < 2) {
                    message.warning('请至少选中 2 个节点');
                    return;
                }
                pushHistory(nodesRef.current);
                const selectedNodes = (nodesRef.current || []).filter(n => selectedNodeIds.includes(n.id));

                let targetValue;
                switch (type) {
                    case 'left':
                        targetValue = Math.min(...selectedNodes.map(n => n.x || 0));
                        setNodes(prev => prev.map(n => selectedNodeIds.includes(n.id) ? { ...n, x: targetValue } : n));
                        break;
                    case 'center-h':
                        const minX = Math.min(...selectedNodes.map(n => n.x || 0));
                        const maxX = Math.max(...selectedNodes.map(n => (n.x || 0) + (n.width || 0)));
                        targetValue = (minX + maxX) / 2;
                        setNodes(prev => prev.map(n => {
                            if (selectedNodeIds.includes(n.id)) {
                                return { ...n, x: targetValue - (n.width || 0) / 2 };
                            }
                            return n;
                        }));
                        break;
                    case 'right':
                        targetValue = Math.max(...selectedNodes.map(n => (n.x || 0) + (n.width || 0)));
                        setNodes(prev => prev.map(n => {
                            if (selectedNodeIds.includes(n.id)) {
                                return { ...n, x: targetValue - (n.width || 0) };
                            }
                            return n;
                        }));
                        break;
                    case 'top':
                        targetValue = Math.min(...selectedNodes.map(n => n.y || 0));
                        setNodes(prev => prev.map(n => selectedNodeIds.includes(n.id) ? { ...n, y: targetValue } : n));
                        break;
                    case 'center-v':
                        const minY = Math.min(...selectedNodes.map(n => n.y || 0));
                        const maxY = Math.max(...selectedNodes.map(n => {
                            const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                            return (n.y || 0) + (n.width || 0) / aspect;
                        }));
                        targetValue = (minY + maxY) / 2;
                        setNodes(prev => prev.map(n => {
                            if (selectedNodeIds.includes(n.id)) {
                                const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                                const height = (n.width || 0) / aspect;
                                return { ...n, y: targetValue - height / 2 };
                            }
                            return n;
                        }));
                        break;
                    case 'bottom':
                        targetValue = Math.max(...selectedNodes.map(n => {
                            const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                            return (n.y || 0) + (n.width || 0) / aspect;
                        }));
                        setNodes(prev => prev.map(n => {
                            if (selectedNodeIds.includes(n.id)) {
                                const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                                const height = (n.width || 0) / aspect;
                                return { ...n, y: targetValue - height };
                            }
                            return n;
                        }));
                        break;
                }
                message.success('对齐完成');
            }, [selectedNodeIds, pushHistory]);

            // ========== 水平/垂直分布 ==========
            const handleDistribute = useCallback((direction) => {
                if (selectedNodeIds.length < 3) {
                    message.warning('请至少选中 3 个节点才能分布');
                    return;
                }
                pushHistory(nodesRef.current);
                const selectedNodes = (nodesRef.current || []).filter(n => selectedNodeIds.includes(n.id));

                if (direction === 'horizontal') {
                    const sorted = [...selectedNodes].sort((a, b) => (a.x || 0) - (b.x || 0));
                    const minX = sorted[0].x || 0;
                    const maxX = (sorted[sorted.length - 1].x || 0) + (sorted[sorted.length - 1].width || 0);
                    const totalWidth = sorted.reduce((sum, n) => sum + (n.width || 0), 0);
                    const gap = (maxX - minX - totalWidth) / (sorted.length - 1);

                    let currentX = minX;
                    const updates = new Map();
                    sorted.forEach(n => {
                        updates.set(n.id, currentX);
                        currentX += (n.width || 0) + gap;
                    });

                    setNodes(prev => prev.map(n => {
                        if (updates.has(n.id)) {
                            return { ...n, x: updates.get(n.id) };
                        }
                        return n;
                    }));
                } else {
                    const getHeight = (n) => {
                        const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                        return (n.width || 0) / aspect;
                    };
                    const sorted = [...selectedNodes].sort((a, b) => (a.y || 0) - (b.y || 0));
                    const minY = sorted[0].y || 0;
                    const maxY = (sorted[sorted.length - 1].y || 0) + getHeight(sorted[sorted.length - 1]);
                    const totalHeight = sorted.reduce((sum, n) => sum + getHeight(n), 0);
                    const gap = (maxY - minY - totalHeight) / (sorted.length - 1);

                    let currentY = minY;
                    const updates = new Map();
                    sorted.forEach(n => {
                        updates.set(n.id, currentY);
                        currentY += getHeight(n) + gap;
                    });

                    setNodes(prev => prev.map(n => {
                        if (updates.has(n.id)) {
                            return { ...n, y: updates.get(n.id) };
                        }
                        return n;
                    }));
                }
                message.success('分布完成');
            }, [selectedNodeIds, pushHistory]);

            // ========== 图层顺序 ==========
            const handleBringForward = useCallback(() => {
                if (selectedNodeIds.length === 0) return;
                pushHistory(nodesRef.current);
                setNodes(prev => {
                    const result = [...prev];
                    selectedNodeIds.forEach(id => {
                        const idx = result.findIndex(n => n.id === id);
                        if (idx < result.length - 1) {
                            [result[idx], result[idx + 1]] = [result[idx + 1], result[idx]];
                        }
                    });
                    return result;
                });
                message.success('上移一层');
            }, [selectedNodeIds, pushHistory]);

            const handleSendBackward = useCallback(() => {
                if (selectedNodeIds.length === 0) return;
                pushHistory(nodesRef.current);
                setNodes(prev => {
                    const result = [...prev];
                    selectedNodeIds.forEach(id => {
                        const idx = result.findIndex(n => n.id === id);
                        if (idx > 0) {
                            [result[idx], result[idx - 1]] = [result[idx - 1], result[idx]];
                        }
                    });
                    return result;
                });
                message.success('下移一层');
            }, [selectedNodeIds, pushHistory]);

            // ========== 右键菜单 ==========
            const rightClickStartRef = useRef(null);

            const handleContextMenu = useCallback((e, nodeId) => {
                e.preventDefault();
                e.stopPropagation();

                // 如果正在平移画布，不显示菜单
                if (isPanning) {
                    return;
                }

                // 检查是否有拖拽移动（超过5px不算点击）
                if (rightClickStartRef.current) {
                    const dx = Math.abs(e.clientX - rightClickStartRef.current.x);
                    const dy = Math.abs(e.clientY - rightClickStartRef.current.y);
                    if (dx > 5 || dy > 5) {
                        rightClickStartRef.current = null;
                        return;
                    }
                }

                if (nodeId && !selectedNodeIds.includes(nodeId)) {
                    setSelectedNodeIds([nodeId]);
                    setSelectedNode(nodeId);
                }
                setContextMenu({ x: e.clientX, y: e.clientY, nodeId });
            }, [selectedNodeIds, isPanning]);

            const closeContextMenu = useCallback(() => {
                setContextMenu(null);
            }, []);

            // 点击画布时关闭右键菜单
            useEffect(() => {
                const handleClick = () => closeContextMenu();
                window.addEventListener('click', handleClick);
                return () => window.removeEventListener('click', handleClick);
            }, [closeContextMenu]);

            const contextMenuItems = useMemo(() => {
                const items = [];
                if (selectedNodeIds.length > 0) {
                    items.push(
                        { key: 'copy', label: '复制', icon: <CopyOutlined />, onClick: handleCopy },
                        { key: 'delete', label: '删除', icon: <DeleteOutlined />, danger: true, onClick: () => handleDeleteNodes() },
                        { type: 'divider' }
                    );
                }
                items.push(
                    { key: 'paste', label: '粘贴', icon: <CopyOutlined />, disabled: clipboard.length === 0, onClick: handlePaste },
                    { type: 'divider' },
                    { key: 'undo', label: '撤销 (Ctrl+Z)', icon: <UndoOutlined />, disabled: historyIndex <= 0, onClick: handleUndo },
                    { key: 'redo', label: '重做 (Ctrl+Y)', icon: <RedoOutlined />, disabled: historyIndex >= history.length - 1, onClick: handleRedo }
                );

                // 锁定/解锁选项
                if (selectedNodeIds.length > 0) {
                    const allLocked = selectedNodeIds.every(id => lockedNodeIds.includes(id));
                    const anyLocked = selectedNodeIds.some(id => lockedNodeIds.includes(id));
                    items.push(
                        { type: 'divider' },
                        allLocked
                            ? { key: 'unlock', label: '解锁节点 (Ctrl+L)', icon: <UnlockOutlined />, onClick: handleUnlockNodes }
                            : { key: 'lock', label: '锁定节点 (Ctrl+L)', icon: <LockOutlined />, onClick: handleLockNodes }
                    );
                }

                // 编组选项
                if (selectedNodeIds.length >= 2) {
                    const hasGroup = selectedNodeIds.some(id => {
                        const node = (nodesRef.current || []).find(n => n.id === id);
                        return node && node.groupId;
                    });
                    items.push(
                        { type: 'divider' },
                        { key: 'group', label: '编组 (Ctrl+G)', icon: <AppstoreOutlined />, onClick: handleGroupNodes }
                    );
                    if (hasGroup) {
                        items.push(
                            { key: 'ungroup', label: '解除编组 (Ctrl+Shift+G)', onClick: handleUngroupNodes }
                        );
                    }
                }

                if (selectedNodeIds.length >= 2) {
                    items.push(
                        { type: 'divider' },
                        { key: 'align-left', label: '左对齐', icon: <AlignLeftOutlined />, onClick: () => handleAlign('left') },
                        { key: 'align-center', label: '水平居中', icon: <AlignCenterOutlined />, onClick: () => handleAlign('center-h') },
                        { key: 'align-right', label: '右对齐', icon: <AlignRightOutlined />, onClick: () => handleAlign('right') },
                        { key: 'align-top', label: '顶对齐', icon: <VerticalAlignTopOutlined />, onClick: () => handleAlign('top') },
                        { key: 'align-middle', label: '垂直居中', icon: <VerticalAlignMiddleOutlined />, onClick: () => handleAlign('center-v') },
                        { key: 'align-bottom', label: '底对齐', icon: <VerticalAlignBottomOutlined />, onClick: () => handleAlign('bottom') }
                    );
                }
                if (selectedNodeIds.length >= 3) {
                    items.push(
                        { type: 'divider' },
                        { key: 'distribute-h', label: '水平分布', onClick: () => handleDistribute('horizontal') },
                        { key: 'distribute-v', label: '垂直分布', onClick: () => handleDistribute('vertical') }
                    );
                }
                if (selectedNodeIds.length > 0) {
                    items.push(
                        { type: 'divider' },
                        { key: 'bring-forward', label: '上移一层', icon: <ArrowUpOutlined />, onClick: handleBringForward },
                        { key: 'send-backward', label: '下移一层', icon: <ArrowDownOutlined />, onClick: handleSendBackward }
                    );
                }
                if (selectedNodeIds.length === 1) {
                    const nodeId = selectedNodeIds[0];
                    if (!['prod', 'ref', 'result'].includes(nodeId)) {
                        items.push(
                            { type: 'divider' },
                            { key: 'set-product', label: '设为产品图', icon: <ShoppingOutlined />, onClick: () => applyNodeAsProduct(nodeId) },
                            { key: 'set-reference', label: '设为参考图', icon: <FileImageOutlined />, onClick: () => applyNodeAsReference(nodeId) }
                        );
                    }
                }
                return items;
            }, [selectedNodeIds, clipboard, historyIndex, history.length, lockedNodeIds, handleCopy, handlePaste, handleDeleteNodes, handleUndo, handleRedo, handleLockNodes, handleUnlockNodes, handleGroupNodes, handleUngroupNodes, handleAlign, handleDistribute, handleBringForward, handleSendBackward]);

            const parseAspectRatioValue = useCallback((value) => {
                const v = String(value || '').trim();
                if (!v || v === 'auto') return 1;
                const m = v.match(/(\d+(?:\.\d+)?)\s*:\s*(\d+(?:\.\d+)?)/);
                if (!m) return 1;
                const a = Number(m[1]);
                const b = Number(m[2]);
                if (!isFinite(a) || !isFinite(b) || a <= 0 || b <= 0) return 1;
                return a / b;
            }, []);

            const handleAddBoard = useCallback(() => {
                const canvasEl = canvasRef.current;
                const rect = canvasEl?.getBoundingClientRect?.();
                const viewW = rect?.width || 980;
                const viewH = rect?.height || 640;

                const v = viewportRef.current || { x: 0, y: 0, scale: 1 };
                const scale = v.scale || 1;
                const aspect = parseAspectRatioValue(aspectRatio);

                const boardWidth = Math.min(980, Math.max(420, (viewW * 0.62) / scale));
                const boardHeight = boardWidth / (aspect || 1);

                const centerWorldX = ((viewW / 2) - (v.x || 0)) / scale;
                const centerWorldY = ((viewH / 2) - (v.y || 0)) / scale;

                const id = `board-${Date.now()}`;
                const node = {
                    id,
                    type: 'board',
                    groupId: 'boards',
                    x: centerWorldX - boardWidth / 2,
                    y: centerWorldY - boardHeight / 2,
                    width: boardWidth,
                    aspect
                };
                setNodes((prev) => ([...(prev || []), node]));
                setSelectedNode(id);
                setSelectedNodeIds([id]);
                message.success('已添加画板');
            }, [aspectRatio, parseAspectRatioValue]);

            // Upload handlers
            const getDataUrlAspect = (dataUrl) => new Promise((resolve) => {
                if (!dataUrl) return resolve(1);
                const img = new Image();
                img.onload = () => {
                    const w = img.naturalWidth || 0;
                    const h = img.naturalHeight || 0;
                    resolve(w > 0 && h > 0 ? (w / h) : 1);
                };
                img.onerror = () => resolve(1);
                img.src = dataUrl;
            });

            const handleRefUpload = (file) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;
                    setRefImage(dataUrl);
                    singleRefFile = file;

                    const aspect = await getDataUrlAspect(dataUrl);
                    setRefAspect(aspect);
                    if (typeof updateElementStatus === 'function') {
                        updateElementStatus('ref-image', true);
                    }
                    log('success', '参考图已加载');
                };
                reader.readAsDataURL(file);
                return false;
            };

            const handleProdUpload = (file) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataUrl = e.target.result;
                    setProdImage(dataUrl);
                    singleProdFile = file;

                    const aspect = await getDataUrlAspect(dataUrl);
                    setProdAspect(aspect);
                    if (typeof updateElementStatus === 'function') {
                        updateElementStatus('prod-image', true);
                    }
                    log('success', '产品图已加载');
                };
                reader.readAsDataURL(file);
                return false;
            };

            const ensureCanvasBoards = (resultDataUrl) => {
                const staged = stagedAssetsRef.current || [];
                if (staged.length) {
                    stagedAssetsRef.current = [];
                    setStagedAssets([]);
                }

                setNodes(prev => {
                    const rest = (prev || []).filter(n => !['prod', 'ref', 'result'].includes(n.id));
                    const top = [];
                    if (prodImage) {
                        top.push({
                            id: 'prod',
                            type: 'product',
                            groupId: 'top',
                            x: 0,
                            y: 0,
                            width: 320,
                            aspect: prodAspect || 1
                        });
                    }
                    if (refImage) {
                        top.push({
                            id: 'ref',
                            type: 'reference',
                            groupId: 'top',
                            x: 0,
                            y: 0,
                            width: 320,
                            aspect: refAspect || 1
                        });
                    }
                    if (resultDataUrl || resultImage) {
                        top.push({
                            id: 'result',
                            type: 'result',
                            groupId: 'top',
                            x: 0,
                            y: 0,
                            width: 320,
                            aspect: 1
                        });
                    }
                    return [...top, ...rest, ...staged];
                });

                requestAutoLayout();

                const url = resultDataUrl || resultImage;
                if (url) {
                    getDataUrlAspect(url).then((aspect) => {
                        if (!aspect || !isFinite(aspect) || aspect <= 0) return;
                        setNodes(prev => prev.map(node => (node.id === 'result' ? { ...node, aspect } : node)));
                        requestAutoLayout();
                    });
                }
            };

            // ========================================
             // Studio Command Bar (search-box style)
             // ========================================
             const handleStudioSubmit = () => {
                 if (guidedStage !== 'idle') {
                     setAiPanelOpen(true);
                     return;
                 }
                 startGuidedFlow({ goal: (studioQuery || '').trim() });
             };

            const handleStudioDropFiles = async (fileList) => {
                const files = Array.from(fileList || []).filter(Boolean);
                if (files.length === 0) return;

                let idx = 0;
                if ((!singleProdFile || !prodImage) && files[idx]) {
                    handleProdUpload(files[idx]);
                    idx += 1;
                }
                if ((!singleRefFile || !refImage) && files[idx]) {
                    handleRefUpload(files[idx]);
                    idx += 1;
                }

                const rest = files.slice(idx);
                if (rest.length) {
                    await handleBatchFiles(rest);
                }

                message.success(`已导入 ${files.length} 张图片`);
            };

            const handleStudioDragOver = (e) => {
                e.preventDefault();
                setStudioDragActive(true);
            };

            const handleStudioDragLeave = () => {
                setStudioDragActive(false);
            };

            const handleStudioDrop = async (e) => {
                try {
                    e.preventDefault();
                    setStudioDragActive(false);
                    const files = e.dataTransfer?.files;
                    if (files && files.length) {
                        // 获取拖拽位置（画布坐标）
                        const dropPoint = getCanvasPoint(e);
                        await handleStudioDropFilesAtPosition(files, dropPoint);
                    }
                } catch (err) {
                    message.error(`导入失败: ${err?.message || err}`);
                }
            };

            // 优化的拖拽导入 - 在指定位置创建节点
            const handleStudioDropFilesAtPosition = async (fileList, dropPoint) => {
                const files = Array.from(fileList || []).filter(Boolean);
                if (files.length === 0) return;

                pushHistory(nodesRef.current);

                // 如果只有一张图且没有产品图，设为产品图
                if (files.length === 1 && !prodImage) {
                    handleProdUpload(files[0]);
                    message.success('已设为产品图');
                    return;
                }

                // 如果有两张图且没有产品图和参考图
                if (files.length === 2 && !prodImage && !refImage) {
                    handleProdUpload(files[0]);
                    handleRefUpload(files[1]);
                    message.success('已设为产品图和参考图');
                    return;
                }

                // 多张图片：在拖拽位置创建批量节点
                const imageFiles = files.filter(f => f.type.startsWith('image/'));
                if (imageFiles.length === 0) {
                    message.warning('请拖入图片文件');
                    return;
                }

                const newNodes = [];
                const NODE_WIDTH = 280;
                const GAP = 20;
                const COLS = Math.ceil(Math.sqrt(imageFiles.length));

                for (let i = 0; i < imageFiles.length; i++) {
                    const file = imageFiles[i];
                    const dataUrl = await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (ev) => resolve(ev.target.result);
                        reader.readAsDataURL(file);
                    });

                    // 计算网格位置
                    const col = i % COLS;
                    const row = Math.floor(i / COLS);
                    const x = (dropPoint?.x || 0) + col * (NODE_WIDTH + GAP);
                    const y = (dropPoint?.y || 0) + row * (NODE_WIDTH + GAP);

                    // 获取图片宽高比
                    const aspect = await new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => resolve(img.width / img.height);
                        img.onerror = () => resolve(1);
                        img.src = dataUrl;
                    });

                    newNodes.push({
                        id: `drop-${Date.now()}-${i}`,
                        type: 'batch',
                        src: dataUrl,
                        fileName: file.name,
                        width: NODE_WIDTH,
                        aspect,
                        x,
                        y
                    });
                }

                setNodes(prev => [...prev, ...newNodes]);
                setSelectedNodeIds(newNodes.map(n => n.id));
                message.success(`已导入 ${newNodes.length} 张图片到画布`);
            };

            // Project Profile handlers
            const handleSaveProfile = async () => {
                try {
                    const values = await profileForm.validateFields();
                    const next = {
                        ...getDefaultProjectProfile(),
                        ...values,
                        version: 1,
                        updated_at: Date.now()
                    };
                    setProjectProfile(next);
                    saveProjectProfile(next);
                    setProfileOpen(false);
                    message.success('品牌档案已保存');
                } catch (err) {
                    // validation errors are handled by antd
                }
            };

            const handleResetProfile = () => {
                const next = getDefaultProjectProfile();
                profileForm.setFieldsValue(next);
                setProjectProfile(next);
                saveProjectProfile(next);
                message.success('已重置品牌档案');
            };

            // ========================================
            // AI 引导生成 handlers
            // ========================================

            const dataUrlToBase64 = (dataUrl) => {
                if (!dataUrl) return '';
                const str = String(dataUrl);
                const idx = str.indexOf(',');
                return idx >= 0 ? str.slice(idx + 1) : str;
            };

             const normalizeStudioLang = (value) => {
                 const v = String(value || '').trim().toLowerCase();
                 if (!v) return 'same';
                 if (v === 'same') return 'same';
                 if (v.startsWith('zh')) return 'zh';
                 if (v.startsWith('en')) return 'en';
                 if (v.startsWith('th')) return 'th';
                 return v;
             };

             const appendChatMessage = (role, content) => {
                 const text = (content == null) ? '' : String(content);
                 if (!text.trim()) return;
                 setChatMessages(prev => [...prev, { role, content: text }]);
             };

             const buildDefaultGuidedBrief = (prefill = {}) => {
                 const prof = projectProfile || getDefaultProjectProfile();
                 const defaultAspect = (aspectRatio && aspectRatio !== 'auto') ? aspectRatio : '1:1';
                 const baseGoal = String(prefill.goal || '').trim();
                 return {
                     output_type: prefill.output_type || ((prof.primary_outputs || []).includes('banner') ? 'banner' : ((prof.primary_outputs || [])[0] || 'main')),
                     goal: baseGoal,
                     aspect_ratio: prefill.aspect_ratio || defaultAspect,
                     target_language: normalizeStudioLang(prefill.target_language || 'same'),
                     text_enabled: false,
                     headline: '',
                     subheadline: '',
                     use_reference: !!singleRefFile,
                     style_preset: prefill.style_preset || prof.default_style_preset || 'generic',
                     fidelity_level: prefill.fidelity_level || prof.fidelity_level || 'strict',
                     candidate_count: Number(prefill.candidate_count || prof.default_candidate_count || 4)
                 };
             };

             const createGuidedQuestions = ({ hasProduct, hasRef, hasGoal }) => {
                 const qs = [];
                 if (!hasProduct && !hasGoal) {
                     qs.push({
                         id: 'goal_required',
                         type: 'text',
                         required: true,
                         prompt: '先告诉我你想生成什么（不上传图也可以）',
                         placeholder: '例如：黑底蓝色点缀的科技感电商主图，产品是…',
                         apply: (brief, value) => ({ ...brief, goal: String(value || '').trim() })
                     });
                 }

                 qs.push({
                     id: 'output_type',
                     type: 'choice',
                     required: true,
                     prompt: '这次主要做什么类型？',
                     options: [
                         { label: '电商主图', value: 'main' },
                         { label: 'Banner 横幅', value: 'banner' },
                         { label: '海报 Poster', value: 'poster' },
                         { label: '社媒图', value: 'social' }
                     ],
                     apply: (brief, value) => ({ ...brief, output_type: value })
                 });

                 qs.push({
                     id: 'style_preset',
                     type: 'choice',
                     required: true,
                     prompt: '想要偏哪个平台/风格？',
                     options: [
                         { label: '通用', value: 'generic' },
                         { label: 'SHEIN', value: 'shein' },
                         { label: 'Amazon', value: 'amazon' },
                         { label: 'TikTok/抖音', value: 'tiktok' }
                     ],
                     apply: (brief, value) => ({ ...brief, style_preset: value })
                 });

                 qs.push({
                     id: 'aspect_ratio',
                     type: 'choice',
                     required: true,
                     prompt: '输出比例？',
                     options: [
                         { label: '1:1', value: '1:1' },
                         { label: '3:4', value: '3:4' },
                         { label: '4:3', value: '4:3' },
                         { label: '9:16', value: '9:16' },
                         { label: '16:9', value: '16:9' }
                     ],
                     apply: (brief, value) => ({ ...brief, aspect_ratio: value })
                 });

                 qs.push({
                     id: 'target_language',
                     type: 'choice',
                     required: true,
                     prompt: '目标语言？（不同则翻译画面文字）',
                     options: [
                         { label: '保持原语言', value: 'same' },
                         { label: '中文', value: 'zh' },
                         { label: '英语', value: 'en' },
                         { label: '泰语', value: 'th' }
                     ],
                     apply: (brief, value) => ({ ...brief, target_language: value })
                 });

                 if (hasProduct) {
                     qs.push({
                         id: 'fidelity_level',
                         type: 'choice',
                         required: true,
                         prompt: '产品保护等级？',
                         options: [
                             { label: '严格（保形保色）', value: 'strict' },
                             { label: '平衡（允许轻微角度）', value: 'balanced' }
                         ],
                         apply: (brief, value) => ({ ...brief, fidelity_level: value })
                     });
                 }

                 if (hasRef) {
                     qs.push({
                         id: 'use_reference',
                         type: 'choice',
                         required: true,
                         prompt: '参考图要作为风格参考吗？',
                         options: [
                             { label: '用参考图', value: true },
                             { label: '不用', value: false }
                         ],
                         apply: (brief, value) => ({ ...brief, use_reference: !!value })
                     });
                 }

                 qs.push({
                     id: 'candidate_count',
                     type: 'choice',
                     required: true,
                     prompt: '先出几张候选？',
                     options: [
                         { label: '1 张', value: 1 },
                         { label: '4 张（推荐）', value: 4 },
                         { label: '8 张', value: 8 }
                     ],
                     apply: (brief, value) => ({ ...brief, candidate_count: Number(value || 4) })
                 });

                 qs.push({
                     id: 'goal_extra',
                     type: 'text_optional',
                     required: false,
                     prompt: '补充一句你想要的效果（可选，回车发送 / 点跳过）',
                     placeholder: '例如：更高级、留白多、背景更有氛围、不要水印…',
                     apply: (brief, value) => {
                         const extra = String(value || '').trim();
                         if (!extra) return brief;
                         const base = String(brief.goal || '').trim();
                         return { ...brief, goal: base ? `${base}\n${extra}` : extra };
                     }
                 });

                 return qs;
             };

             const askGuidedQuestion = (index, questions) => {
                 const qs = Array.isArray(questions) ? questions : (guidedQuestions || []);
                 const q = qs[index];
                 if (!q) return;
                 appendChatMessage('ai', `问题 ${index + 1}/${qs.length}：${q.prompt}`);
             };

             const startGuidedFlow = (prefill = {}) => {
                 const hasProduct = !!singleProdFile && !!prodImage;
                 const hasRef = !!singleRefFile && !!refImage;

                 const brief = buildDefaultGuidedBrief(prefill);
                 guidedBriefRef.current = brief;
                 setGuidedBrief(brief);

                 const qs = createGuidedQuestions({ hasProduct, hasRef, hasGoal: !!String(brief.goal || '').trim() });
                 setGuidedQuestions(qs);
                 setGuidedQuestionIndex(0);
                 setGuidedStage('qa');
 
                 setGuidedPlan(null);
                 setGuidedDirections([]);
                 guidedDirectionsRef.current = [];
                 setGuidedSelectedId('A');
                   setGuidedCandidates([]);

                  setAiPanelOpen(true);
                  setStudioQuery('');

                  setChatMessages(prev => {
                     const next = [...prev];
                     next.push({ role: 'ai', content: '好的，我们开始。' });
                     next.push({ role: 'ai', content: '计划：1 分析素材 2 给 3 个方向 3 生成候选 4 你挑一张再精修。' });
                     if (brief.goal) next.push({ role: 'ai', content: `本次目标：${brief.goal}` });
                     const firstQ = qs[0];
                     if (firstQ) next.push({ role: 'ai', content: `问题 1/${qs.length}：${firstQ.prompt}` });
                     return next;
                 });
             };

             const handleGuidedBuildPlan = async (overrideBrief) => {
                 try {
                     const values = overrideBrief || guidedBriefRef.current || guidedBrief || {};
                     const requiredFields = ['output_type', 'aspect_ratio', 'target_language'];
                     for (const k of requiredFields) {
                         if (!String(values[k] || '').trim()) {
                             throw new Error('关键信息不足，请先完成问答');
                         }
                     }
                     setGuidedLoadingPlan(true);

                     const assets = {};
                     const prodBase64 = dataUrlToBase64(prodImage);
                     if (prodBase64) {
                        const prodDesc = await Api.post('/api/vision/describe', {
                            image_base64: prodBase64,
                            context: '产品图（用于生成计划，不用于展示）'
                        });
                        if (prodDesc?.success) assets.product_description = prodDesc.description;
                    }

                    const refBase64 = dataUrlToBase64(refImage);
                    if (refBase64) {
                        const refDesc = await Api.post('/api/vision/describe', {
                            image_base64: refBase64,
                            context: '参考图/风格参考（用于生成计划，不用于展示）'
                        });
                        if (refDesc?.success) assets.reference_description = refDesc.description;
                    }

                     const brief = {
                         ...values,
                         target_language: normalizeStudioLang(values.target_language || 'same'),
                         has_reference: !!singleRefFile,
                         use_reference: !!values.use_reference
                     };

                     const planResult = await Api.post('/api/studio/plan', {
                        profile: projectProfile || getDefaultProjectProfile(),
                        brief,
                        assets
                    });

                    if (!planResult?.success || !planResult?.data) {
                        throw new Error(planResult?.message || '计划生成失败');
                    }

                     const data = planResult.data;
                     setGuidedPlan(Array.isArray(data.plan) ? data.plan : null);
                     setGuidedDirections(Array.isArray(data.directions) ? data.directions : []);
                     setGuidedSelectedId((data.directions || [])[0]?.id || 'A');
                     setGuidedStage('plan');
                     return data;
                 } catch (error) {
                     message.error(`生成计划失败: ${error.message}`);
                     throw error;
                 } finally {
                     setGuidedLoadingPlan(false);
                 }
             };

            const downloadDataUrl = (dataUrl, filename) => {
                try {
                    const a = document.createElement('a');
                    a.href = dataUrl;
                    a.download = filename || `xobi_${Date.now()}.png`;
                    a.click();
                } catch { }
            };

            const getNodeDataUrl = (node) => {
                if (!node) return '';
                if (node.type === 'reference') return refImage || '';
                if (node.type === 'product') return prodImage || '';
                if (node.type === 'result') return resultImage || '';
                if (node.type === 'batch') return node.src || '';
                return '';
            };

            const dataUrlToFile = (dataUrl, filename) => {
                try {
                    if (!dataUrl || typeof dataUrl !== 'string' || !dataUrl.startsWith('data:')) return null;
                    const [meta, b64] = dataUrl.split(',');
                    const mime = (meta.match(/data:(.*?);base64/) || [])[1] || 'image/png';
                    const bin = atob(b64 || '');
                    const bytes = new Uint8Array(bin.length);
                    for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
                    return new File([bytes], filename || `xobi_${Date.now()}.png`, { type: mime });
                } catch {
                    return null;
                }
            };

            const applyNodeAsProduct = async (nodeId) => {
                const node = (nodesRef.current || []).find(n => n.id === nodeId);
                const dataUrl = getNodeDataUrl(node);
                if (!dataUrl) return message.warning('未找到图片数据');
                const file = node?.file || dataUrlToFile(dataUrl, `product_${Date.now()}.png`);
                if (!file) return message.warning('无法读取该图片');
                handleProdUpload(file);
                message.success('已设为产品图');
            };

            const applyNodeAsReference = async (nodeId) => {
                const node = (nodesRef.current || []).find(n => n.id === nodeId);
                const dataUrl = getNodeDataUrl(node);
                if (!dataUrl) return message.warning('未找到图片数据');
                const file = node?.file || dataUrlToFile(dataUrl, `reference_${Date.now()}.png`);
                if (!file) return message.warning('无法读取该图片');
                handleRefUpload(file);
                message.success('已设为参考图');
            };

            const exportNodesAsBoard = async (nodeList, filenamePrefix) => {
                try {
                    const nodesToDraw = (nodeList || []).map((n) => {
                        const src = getNodeDataUrl(n);
                        if (!src) return null;
                        const aspect = (n.aspect && isFinite(n.aspect) && n.aspect > 0) ? n.aspect : 1;
                        const width = Number(n.width || 0);
                        const height = width / aspect;
                        return { node: n, src, x: n.x, y: n.y, width, height };
                    }).filter(Boolean);

                    if (nodesToDraw.length === 0) {
                        message.warning('没有可导出的图片');
                        return;
                    }

                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    nodesToDraw.forEach((n) => {
                        minX = Math.min(minX, n.x);
                        minY = Math.min(minY, n.y);
                        maxX = Math.max(maxX, n.x + n.width);
                        maxY = Math.max(maxY, n.y + n.height);
                    });

                    const exportScale = 2;
                    const canvas = document.createElement('canvas');
                    const w = Math.max(1, Math.ceil((maxX - minX) * exportScale));
                    const h = Math.max(1, Math.ceil((maxY - minY) * exportScale));
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) throw new Error('Canvas 初始化失败');
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, w, h);

                    const loadImage = (src) => new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = () => reject(new Error('图片加载失败'));
                        img.src = src;
                    });

                    const imgs = await Promise.all(nodesToDraw.map(async (n) => ({ ...n, img: await loadImage(n.src) })));
                    imgs.forEach((n) => {
                        const dx = (n.x - minX) * exportScale;
                        const dy = (n.y - minY) * exportScale;
                        const dw = n.width * exportScale;
                        const dh = n.height * exportScale;
                        ctx.drawImage(n.img, dx, dy, dw, dh);
                    });

                    const out = canvas.toDataURL('image/png');
                    downloadDataUrl(out, `${filenamePrefix || 'board'}_${Date.now()}.png`);
                } catch (err) {
                    message.error(`导出失败: ${err?.message || err}`);
                }
            };

            const handleDownloadSelection = async () => {
                const ids = selectedNodeIds || [];
                if (ids.length === 0) return;
                const list = (nodesRef.current || []).filter(n => ids.includes(n.id));
                if (list.length === 0) return;
                if (list.length === 1) {
                    const n = list[0];
                    const src = getNodeDataUrl(n);
                    if (!src) return message.warning('未找到图片数据');
                    downloadDataUrl(src, `xobi_${n.type}_${Date.now()}.png`);
                    return;
                }
                list.forEach((n, idx) => {
                    const src = getNodeDataUrl(n);
                    if (src) downloadDataUrl(src, `xobi_${n.type}_${idx + 1}_${Date.now()}.png`);
                });
                message.success(`已触发下载 ${list.length} 张`);
            };

            const handleExportSelectionBoard = async () => {
                const ids = selectedNodeIds || [];
                if (ids.length === 0) return;
                const list = (nodesRef.current || []).filter(n => ids.includes(n.id));
                await exportNodesAsBoard(list, 'selection');
            };

            const handleExportFullBoard = async () => {
                const list = (nodesRef.current || []).filter(n => getNodeDataUrl(n));
                await exportNodesAsBoard(list, 'canvas');
            };

             const applyCandidateAsResult = (candidate) => {
                 if (!candidate || !candidate.image_data) return;
                 singleResultData = candidate.image_data;
                 setResultImage(candidate.dataUrl);
                 ensureCanvasBoards(candidate.dataUrl);
                 setGuidedStage('idle');
                 setGuidedCandidates([]);
                 message.success('已选中该版本，可继续标注精修');
             };

             const handleGuidedGenerateCandidates = async (overrideDirectionId, overrideBrief) => {
                 if (!guidedDirections || guidedDirections.length === 0) {
                     message.warning('请先生成计划并选择方向');
                     return;
                 }

                 try {
                     const values = overrideBrief || guidedBriefRef.current || guidedBrief || {};
                     const targetDirId = overrideDirectionId || guidedSelectedId;
                     const dir = guidedDirections.find(d => d.id === targetDirId) || guidedDirections[0];
                     if (!dir) throw new Error('缺少方向数据');

                     const candidateCount = Math.max(1, Math.min(8, Number(values.candidate_count || 4)));
                     const targetLang = normalizeStudioLang(values.target_language || 'same');
                     const aspect = String(values.aspect_ratio || dir.recommended_aspect_ratio || '1:1');
                     const hasProduct = !!singleProdFile && !!prodImage;
                     if (!hasProduct && !String(values.goal || '').trim()) {
                         message.warning('请先输入你想生成的内容（或上传产品图）');
                         return;
                     }

                     const textEnabled = !!values.text_enabled;
                     const headline = (values.headline || '').trim();
                     const subheadline = (values.subheadline || '').trim();
                     const copyText = textEnabled ? [headline, subheadline].filter(Boolean).join('\n') : '';

                     const fidelity = String(values.fidelity_level || projectProfile?.fidelity_level || 'strict');
                     const options = { ...(dir.options || {}) };
                     if (fidelity === 'strict') options.change_angle = false;

                    const reqParts = [];
                    if (dir.requirements) reqParts.push(String(dir.requirements).trim());
                    if (projectProfile?.brand_style_keywords) reqParts.push(`品牌关键词：${projectProfile.brand_style_keywords}`);
                    if (projectProfile?.forbidden) reqParts.push(`红线：${projectProfile.forbidden}`);
                    if (values.goal && String(values.goal).trim()) reqParts.push(`本次目标：${String(values.goal).trim()}`);
                    if (hasProduct) {
                        reqParts.push('产品要求：保持真实结构与颜色，不变形，不要额外Logo/水印，细节清晰。');
                    } else {
                        reqParts.push('要求：画面干净无水印/Logo；构图清晰、质感商业化。');
                    }

                    const baseRequirements = reqParts.filter(Boolean).join('\n');

                    setGuidedGenerating(true);
                    setGuidedCandidates([]);

                    const generated = [];
                    for (let i = 0; i < candidateCount; i++) {
                        const formData = new FormData();
                        if (hasProduct) {
                            formData.append('product_image', singleProdFile);
                        }
                        if (singleRefFile && values.use_reference) {
                            formData.append('style_reference_image', singleRefFile);
                        }
                        formData.append('style_preset', dir.style_preset || values.style_preset || 'generic');
                        formData.append('options_json', JSON.stringify(options || {}));
                        const variationHint = hasProduct
                            ? '请在背景/构图/道具上做不同尝试，但产品保持一致。'
                            : '请在构图/光影/场景上做不同尝试，但核心主题与风格一致。';
                        formData.append('requirements', `${baseRequirements}\n候选 ${i + 1}/${candidateCount}：${variationHint}`);
                        formData.append('target_language', targetLang || 'same');
                        formData.append('aspect_ratio', aspect);
                        formData.append('copy_text', copyText);

                        const res = await Api.post(hasProduct ? '/api/style/single' : '/api/style/text', formData, true);
                        if (!res?.success || !res?.image_data) {
                            throw new Error(res?.message || '生成失败');
                        }
                        generated.push({
                            index: i,
                            image_data: res.image_data,
                            dataUrl: `data:image/png;base64,${res.image_data}`,
                            output_url: res.output_url || ''
                        });
                    }

                     setGuidedCandidates(generated);
                     setGuidedStage('candidates');
                     return generated;
                 } catch (error) {
                     message.error(`生成失败: ${error.message}`);
                     throw error;
                 } finally {
                     setGuidedGenerating(false);
                 }
             };

             const handleGuidedChooseOption = (q, option) => {
                 if (!q || !option) return;
                 if (guidedLoadingPlan || guidedGenerating) return;

                 const optLabel = option.label != null ? String(option.label) : String(option.value);
                 appendChatMessage('user', optLabel);

                 setGuidedBrief(prev => {
                     const base = prev || guidedBriefRef.current || buildDefaultGuidedBrief({});
                     const next = q.apply ? q.apply(base, option.value) : { ...base, [q.id]: option.value };
                     guidedBriefRef.current = next;
                     return next;
                 });

                 if (q.id === 'aspect_ratio') {
                     setAspectRatio(String(option.value || '1:1'));
                 }

                 const nextIndex = guidedQuestionIndex + 1;
                 if (nextIndex < (guidedQuestions || []).length) {
                     setGuidedQuestionIndex(nextIndex);
                     askGuidedQuestion(nextIndex, guidedQuestions);
                 } else {
                     (async () => {
                         try {
                             setGuidedStage('plan');
                             appendChatMessage('ai', '收到，我开始分析素材并给出 3 个方向…');
                             await handleGuidedBuildPlan(guidedBriefRef.current);
                             appendChatMessage('ai', '计划已就绪：选择一个方向，然后生成候选。');
                         } catch { }
                     })();
                 }
             };

             const handleGuidedSkipQuestion = () => {
                 const q = (guidedQuestions || [])[guidedQuestionIndex];
                 if (!q) return;
                 if (q.required && (q.type === 'text') && !String(guidedBriefRef.current?.goal || '').trim()) {
                     message.warning('这个问题需要回答一下（否则无法文生图）');
                     return;
                 }
                 appendChatMessage('user', '跳过');
                 const nextIndex = guidedQuestionIndex + 1;
                 if (nextIndex < (guidedQuestions || []).length) {
                     setGuidedQuestionIndex(nextIndex);
                     askGuidedQuestion(nextIndex, guidedQuestions);
                 } else {
                     (async () => {
                         try {
                             setGuidedStage('plan');
                             appendChatMessage('ai', '收到，我开始分析素材并给出 3 个方向…');
                             await handleGuidedBuildPlan(guidedBriefRef.current);
                             appendChatMessage('ai', '计划已就绪：选择一个方向，然后生成候选。');
                         } catch { }
                     })();
                 }
             };

             const handleGuidedExit = () => {
                 setGuidedStage('idle');
                 setGuidedQuestions([]);
                 setGuidedQuestionIndex(0);
             };

             const handleGuidedImmediate = async () => {
                 try {
                     if (guidedLoadingPlan || guidedGenerating) return;
                     const hasProduct = !!singleProdFile && !!prodImage;
                     const brief = guidedBriefRef.current || guidedBrief || {};
                     if (!hasProduct && !String(brief.goal || '').trim()) {
                         message.warning('请先输入你想生成的内容（或上传产品图）');
                         return;
                     }
                     appendChatMessage('user', '立即出图');
                     setGuidedStage('plan');
                     appendChatMessage('ai', '好的，我将使用当前信息直接生成方向并出候选…');
                     const planData = await handleGuidedBuildPlan(brief);
                     const firstId = (planData?.directions || [])[0]?.id || guidedSelectedId || 'A';
                     setGuidedSelectedId(firstId);
                     appendChatMessage('ai', `采用方向 ${firstId}，开始生成候选…`);
                     await handleGuidedGenerateCandidates(firstId, brief);
                     appendChatMessage('ai', '候选已生成，挑一张作为最终版本。');
                 } catch { }
             };

            // Generate image
            const handleGenerate = async () => {
                if (!singleRefFile || !singleProdFile) {
                    message.warning('请先上传参考图和产品图');
                    return;
                }

                setIsGenerating(true);
                // Loading state is now handled by button loading prop

                try {
                    const formData = new FormData();
                    formData.append('reference_image', singleRefFile);
                    formData.append('product_image', singleProdFile);
                    formData.append('product_name', productName || '产品');
                    if (customPrompt) formData.append('custom_text', customPrompt);
                    formData.append('quality', quality);
                    formData.append('aspect_ratio', aspectRatio);
                    formData.append('platform', platform);
                    formData.append('image_type', imageType);
                    formData.append('image_style', imageStyle);
                    formData.append('background_type', backgroundType);
                    formData.append('language', imageLanguage);

                    const timeoutPromise = new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('生成请求超时 (300s)')), 300000)
                    );

                    const apiPromise = Api.post('/api/replace/single', formData, true);
                    const data = await Promise.race([apiPromise, timeoutPromise]);

                    if (data.success && data.image_data) {
                        singleResultData = data.image_data;
                        const outDataUrl = `data:image/png;base64,${data.image_data}`;
                        setResultImage(outDataUrl);
                        ensureCanvasBoards(outDataUrl);
                        log('success', '✅ 单图生成成功');

                        setChatMessages(prev => [...prev, {
                            role: 'ai',
                            content: '✅ 生成完成，图片已显示，可点击下载按钮保存。'
                        }]);

                        // Update element status
                        if (typeof updateElementStatus === 'function') {
                            updateElementStatus('result-image', true);
                        }
                    } else {
                        throw new Error(data.error || '生成失败');
                    }
                } catch (error) {
                    log('error', `生成出错: ${error.message}`);
                    message.error(`生成失败: ${error.message}`);
                } finally {
                    setIsGenerating(false);
                    // Loading state is now handled by button loading prop
                }
            };

            // Download result
            const handleDownload = () => {
                if (!singleResultData) return;
                const a = document.createElement('a');
                a.href = `data:image/png;base64,${singleResultData}`;
                a.download = `xobi_single_${Date.now()}.png`;
                a.click();
                message.success('下载成功');
            };

            // Add to queue
            const handleAddToQueue = () => {
                if (!singleRefFile || !singleProdFile) {
                    message.warning('请先上传参考图和产品图');
                    return;
                }

                if (!window.taskQueue) {
                    message.error('任务队列未初始化');
                    return;
                }

                const taskId = window.taskQueue.addTask({
                    type: 'generation',
                    params: {
                        referenceImage: singleRefFile,
                        productImage: singleProdFile,
                        productName: productName || '产品',
                        customPrompt: customPrompt,
                        quality: quality,
                        aspectRatio: aspectRatio,
                        platform: platform,
                        imageType: imageType,
                        imageStyle: imageStyle,
                        backgroundType: backgroundType,
                        language: imageLanguage
                    }
                });

                message.success('宸叉坊鍔犲埌浠诲姟闃熷垪');
                loadQueueTasks();
                setQueueVisible(true);
            };

            // Preview
            const handlePreview = async () => {
                if (!singleRefFile || !singleProdFile) {
                    message.warning('请先上传参考图和产品图');
                    return;
                }

                setIsPreviewing(true);

                try {
                    const formData = new FormData();
                    formData.append('product_image', singleProdFile);
                    formData.append('reference_image', singleRefFile);
                    formData.append('custom_prompt', customPrompt || '生成商品主图');

                    const response = await fetch('/api/editor/preview', {
                        method: 'POST',
                        body: formData
                    });

                    const data = await response.json();

                    if (data.success && data.preview_data) {
                        setPreviewImage(`data:${data.mime_type || 'image/png'};base64,${data.preview_data}`);
                        setPreviewVisible(true);
                    } else {
                        throw new Error(data.message || '预览生成失败');
                    }
                } catch (error) {
                    message.error(`预览失败: ${error.message}`);
                } finally {
                    setIsPreviewing(false);
                }
            };

            // Chat send
             const handleChatSend = async (msg) => {
                  const text = String(msg || '').trim();
                  if (!text) return;

                  const currentQ = (guidedStage === 'qa') ? (guidedQuestions || [])[guidedQuestionIndex] : null;
                  if (guidedStage === 'qa' && currentQ && (currentQ.type === 'text' || currentQ.type === 'text_optional')) {
                     // Treat as guided answer
                     setChatMessages(prev => [...prev, { role: 'user', content: text }]);
                     setInputValue('');
                     setGuidedBrief(prev => {
                         const base = prev || guidedBriefRef.current || buildDefaultGuidedBrief({});
                         const next = currentQ.apply ? currentQ.apply(base, text) : { ...base, goal: text };
                         guidedBriefRef.current = next;
                         return next;
                     });
                     const nextIndex = guidedQuestionIndex + 1;
                     if (nextIndex < (guidedQuestions || []).length) {
                         setGuidedQuestionIndex(nextIndex);
                         askGuidedQuestion(nextIndex, guidedQuestions);
                     } else {
                         (async () => {
                             try {
                                 setGuidedStage('plan');
                                 appendChatMessage('ai', '收到，我开始分析素材并给出 3 个方向…');
                                 await handleGuidedBuildPlan(guidedBriefRef.current);
                                 appendChatMessage('ai', '计划已就绪：选择一个方向，然后生成候选。');
                             } catch { }
                         })();
                     }
                      return;
                  }

                  const inferCandidateCount = (raw, fallbackCount) => {
                      const fallback = Number(fallbackCount || 4);
                      const t = String(raw || '');
                      const digit = t.match(/(\d+)\s*张/);
                      if (digit) {
                          const n = Number(digit[1]);
                          if (isFinite(n)) return Math.max(1, Math.min(8, n));
                      }
                      const cnMap = [
                          ['一', 1], ['二', 2], ['两', 2], ['三', 3], ['四', 4], ['五', 5], ['六', 6], ['七', 7], ['八', 8],
                      ];
                      for (const [k, v] of cnMap) {
                          if (t.includes(`${k}张`)) return v;
                      }
                      if (t.includes('一张') || t.includes('1张')) return 1;
                      return Math.max(1, Math.min(8, fallback || 4));
                  };

                  const inferAspect = (raw) => {
                      const t = String(raw || '');
                      const m = t.match(/(1:1|3:4|4:3|9:16|16:9)/);
                      return m ? m[1] : '';
                  };

                  const mergeGoal = (baseGoal, extra) => {
                      const a = String(baseGoal || '').trim();
                      const b = String(extra || '').trim();
                      if (!b) return a;
                      if (!a) return b;
                      if (a.includes(b)) return a;
                      return `${a}\n${b}`;
                  };

                  // Add user message
                  setChatMessages(prev => [...prev, { role: 'user', content: text }]);
                  setInputValue('');

                  // Lovart-style: chat drives generation/refine (avoid old /api/chat -> handleGenerate)
                  try {
                      // If we haven't started anything yet, treat as "new goal" and enter guided flow.
                      if (guidedStage === 'idle' && !resultImage && !prodImage && !String((guidedBriefRef.current || guidedBrief || {}).goal || '').trim()) {
                          startGuidedFlow({ goal: text });
                          return;
                      }

                      const base = guidedBriefRef.current || guidedBrief || buildDefaultGuidedBrief({});
                      const nextAspect = inferAspect(text) || String(base.aspect_ratio || '') || '';
                      const nextCount = inferCandidateCount(text, base.candidate_count || 4);
                      const nextBrief = {
                          ...base,
                          goal: mergeGoal(base.goal, text),
                          candidate_count: nextCount,
                          ...(nextAspect ? { aspect_ratio: nextAspect } : {})
                      };
                      guidedBriefRef.current = nextBrief;
                      setGuidedBrief(nextBrief);
                      if (nextAspect) setAspectRatio(nextAspect);

                      appendChatMessage('ai', nextCount === 1 ? '收到，我会按你的补充生成 1 张更贴近的版本…' : `收到，我会按你的补充生成 ${nextCount} 张候选…`);

                      // Ensure we have directions; if not, build a plan first.
                      if (!guidedDirections || guidedDirections.length === 0) {
                          setGuidedStage('plan');
                          await handleGuidedBuildPlan(nextBrief);
                      }

                      const generated = await handleGuidedGenerateCandidates(undefined, nextBrief);
                      if (Array.isArray(generated) && generated.length === 1) {
                          applyCandidateAsResult(generated[0]);
                          appendChatMessage('ai', '已更新到画布（你也可以继续补充要求再精修）。');
                      } else {
                          appendChatMessage('ai', '候选已生成：在上方点「选这张」选择最终版本。');
                      }
                  } catch (error) {
                      message.error(`处理失败: ${error?.message || error}`);
                  }
              };

            // Toggle annotation mode
            const handleToggleAnnotation = () => {
                if (!resultImage) {
                    message.warning('请先生成图片才能添加标注');
                    return;
                }

                if (annotatorRef.current) {
                    annotatorRef.current.toggle();
                    setAnnotationMode(!annotationMode);
                }
            };

            // Toggle reference image annotation mode
            const handleToggleRefAnnotation = () => {
                if (!refImage) {
                    message.warning('请先上传参考图片才能添加标注');
                    return;
                }

                if (refAnnotatorRef.current) {
                    refAnnotatorRef.current.toggle();
                    setRefAnnotationMode(!refAnnotationMode);
                }
            };

            // Toggle product image annotation mode
            const handleToggleProdAnnotation = () => {
                if (!prodImage) {
                    message.warning('请先上传产品图片才能添加标注');
                    return;
                }

                if (prodAnnotatorRef.current) {
                    prodAnnotatorRef.current.toggle();
                    setProdAnnotationMode(!prodAnnotationMode);
                }
            };

            // Submit annotations
            const handleSubmitAnnotations = () => {
                if (annotatorRef.current) {
                    const annots = annotatorRef.current.getAnnotations();
                    if (annots.length === 0) {
                        message.info('娌℃湁寰呭鐞嗙殑鏍囨敞');
                        return;
                    }

                    const annotationText = annots.map((a, i) => `${i + 1}. ${a.text}`).join('\n');
                    handleChatSend(`一张精修：我需要修改以下位置：\n${annotationText}`);
                }
            };

            // Clear annotations
            const handleClearAnnotations = () => {
                if (annotatorRef.current) {
                    Modal.confirm({
                        title: '确认清空',
                        content: '确定要清空所有标注吗？',
                        onOk: () => {
                            annotatorRef.current.clearAnnotations();
                            setAnnotations([]);
                        }
                    });
                }
            };

            // Get config headers for API requests
            const getConfigHeaders = () => {
                const config = window.ConfigManager ? ConfigManager.getConfig() : {};
                const headers = {};

                if (config.yunwu_api_key) {
                    headers['X-Yunwu-Api-Key'] = config.yunwu_api_key;
                    headers['X-Yunwu-Base-Url'] = config.yunwu_base_url;
                    headers['X-Gemini-Flash-Model'] = config.gemini_flash_model;
                    headers['X-Gemini-Image-Model'] = config.gemini_image_model;
                }

                return headers;
            };

            // Smart Annotation - Helper function to convert image to base64
            const imageToBase64 = (imgSrc) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'Anonymous';
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        const base64 = canvas.toDataURL('image/jpeg').split(',')[1];
                        resolve(base64);
                    };
                    img.onerror = reject;
                    img.src = imgSrc;
                });
            };

            // Smart annotation for reference image
            const handleSmartAnnotateRef = async () => {
                if (!refImage || !refAnnotatorRef.current) return;

                try {
                    message.loading({ content: '💡 AI 正在分析参考图...', key: 'smart-ref', duration: 0 });

                    const base64 = await imageToBase64(refImage);
                    const response = await fetch('/api/vision/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...getConfigHeaders() },
                        body: JSON.stringify({
                            image_base64: base64,
                            image_type: 'reference',
                            analysis_type: 'annotation'
                        })
                    });

                    const result = await response.json();
                    message.destroy('smart-ref');

                    if (result.success && result.suggestions.length > 0) {
                        // Clear existing annotations
                        refAnnotatorRef.current.clearAnnotations();

                        // Add AI suggestions
                        result.suggestions.forEach((suggestion) => {
                            refAnnotatorRef.current.addAnnotation(suggestion.x, suggestion.y, suggestion.text);
                        });

                        message.success(`✅ AI 已添加${result.suggestions.length} 个标注点`);
                        log('info', `[AI Vision] ${result.description}`);
                    } else {
                        message.warning('AI 未发现需要标注的特征');
                    }
                } catch (error) {
                    message.destroy('smart-ref');
                    message.error(`分析失败: ${error.message}`);
                }
            };

            // Smart annotation for product image
            const handleSmartAnnotateProd = async () => {
                if (!prodImage || !prodAnnotatorRef.current) return;

                try {
                    message.loading({ content: '💡 AI 正在分析产品图...', key: 'smart-prod', duration: 0 });

                    const base64 = await imageToBase64(prodImage);
                    const response = await fetch('/api/vision/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...getConfigHeaders() },
                        body: JSON.stringify({
                            image_base64: base64,
                            image_type: 'product',
                            analysis_type: 'annotation'
                        })
                    });

                    const result = await response.json();
                    message.destroy('smart-prod');

                    if (result.success && result.suggestions.length > 0) {
                        prodAnnotatorRef.current.clearAnnotations();

                        result.suggestions.forEach((suggestion) => {
                            prodAnnotatorRef.current.addAnnotation(suggestion.x, suggestion.y, suggestion.text);
                        });

                        message.success(`✅ AI 已添加${result.suggestions.length} 个标注点`);
                        log('info', `[AI Vision] ${result.description}`);
                    } else {
                        message.warning('AI 未发现需要标注的特征');
                    }
                } catch (error) {
                    message.destroy('smart-prod');
                    message.error(`分析失败: ${error.message}`);
                }
            };

            // Smart annotation for result image
            const handleSmartAnnotateResult = async () => {
                if (!resultImage || !annotatorRef.current) return;

                try {
                    message.loading({ content: '💡 AI 正在分析生成结果...', key: 'smart-result', duration: 0 });

                    const base64 = await imageToBase64(resultImage);
                    const response = await fetch('/api/vision/analyze', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', ...getConfigHeaders() },
                        body: JSON.stringify({
                            image_base64: base64,
                            image_type: 'result',
                            analysis_type: 'annotation'
                        })
                    });

                    const result = await response.json();
                    message.destroy('smart-result');

                    if (result.success && result.suggestions.length > 0) {
                        annotatorRef.current.clearAnnotations();

                        result.suggestions.forEach((suggestion) => {
                            annotatorRef.current.addAnnotation(suggestion.x, suggestion.y, suggestion.text);
                        });

                        message.success(`✅ AI 已添加${result.suggestions.length} 个标注点`);
                        log('info', `[AI Vision] ${result.description}`);
                    } else {
                        message.warning('AI 未发现需要改进的地方');
                    }
                } catch (error) {
                    message.destroy('smart-result');
                    message.error(`分析失败: ${error.message}`);
                }
            };

            // Queue operations
            const handleRunQueue = () => {
                if (window.taskQueue) {
                    window.taskQueue.runAll();
                    const interval = setInterval(() => {
                        loadQueueTasks();
                        if (!window.taskQueue.isRunning) {
                            clearInterval(interval);
                        }
                    }, 1000);
                }
            };

            const handleClearQueue = () => {
                Modal.confirm({
                    title: '确认清空',
                    content: '确定要清空队列吗？',
                    onOk: () => {
                        if (window.taskQueue) {
                            window.taskQueue.clearQueue();
                            loadQueueTasks();
                        }
                    }
                });
            };

            const selectionScreenRect = React.useMemo(() => {
                if (!selectedNodeIds || selectedNodeIds.length === 0) return null;
                const list = (nodes || []).filter(n => selectedNodeIds.includes(n.id));
                if (list.length === 0) return null;

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                list.forEach((node) => {
                    const aspect = (node.aspect && isFinite(node.aspect) && node.aspect > 0) ? node.aspect : 1;
                    const width = Number(node.width || 0);
                    const height = width / aspect;
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x + width);
                    maxY = Math.max(maxY, node.y + height);
                });

                const scale = viewport.scale || 1;
                const x = minX * scale + viewport.x;
                const y = minY * scale + viewport.y;
                const w = (maxX - minX) * scale;
                const h = (maxY - minY) * scale;
                return { x, y, w, h, cx: x + w / 2, cy: y + h / 2 };
            }, [selectedNodeIds, nodes, viewport]);

            return (
                <Layout style={{ height: '100vh' }}>
                    {/* Header */}
                    <Header>
                        <div className="flex-between">
                            <div>
                                <span style={{ fontSize: '18px', fontWeight: 600, color: 'var(--text-primary)' }}>Xobi v3 - 单图创作</span>
                                <span style={{ marginLeft: '16px', color: 'var(--text-secondary)', fontSize: '14px' }}>
                                    AI 智能合成电商主图
                                </span>
                            </div>
                            <Space>
                                <Button icon={<BookOutlined />} onClick={() => setProfileOpen(true)}>
                                    品牌档案
                                </Button>
                                <Button icon={<SettingOutlined />} onClick={() => window.location.href = 'settings-antdx.html'}>
                                    API 配置
                                </Button>
                                <Button icon={<HomeOutlined />} onClick={() => window.location.href = 'index-antdx.html'}>
                                    返回首页
                                </Button>
                            </Space>
                        </div>
                    </Header>

                    <Layout>
                        {/* Main Content */}
                        <Content style={{ height: '100%', overflow: 'hidden' }}>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr', height: '100%' }}>
                                {false && (
                                <div style={{ padding: '16px', borderRight: '1px solid var(--border-color)', background: 'var(--bg-primary)', overflowY: 'auto' }}>
                                    <Card title={<span><ControlOutlined /> 控制面板</span>} className="mb-16" size="small" bodyStyle={{ padding: '16px', display: 'flex', flexDirection: 'column', gap: '12px' }}>
                                        <div style={{ display: 'grid', gap: '10px' }}>
                                            <div>
                                                <div style={{ fontSize: '12px', color: 'var(--text-secondary)', marginBottom: '6px' }}>产品名称</div>
                                                <Input size="middle" allowClear placeholder="例如：真皮沙发" value={productName} onChange={(e) => setProductName(e.target.value)} />
                                            </div>
                                            <div>
                                                <div style={{ fontSize: '12px', color: 'var(--text-secondary)', marginBottom: '6px' }}>自定义指令（可选）</div>
                                                <Input size="middle" allowClear placeholder="留空则由 AI 自动分析" value={customPrompt} onChange={(e) => setCustomPrompt(e.target.value)} />
                                            </div>
                                        </div>

                                        <div className="control-section-title">生成参数</div>
                                        <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '12px' }}>
                                            <div className="control-chip">
                                                <span className="chip-label">画质</span>
                                                <Segmented block size="small" options={['1K', '2K', '4K']} value={quality} onChange={setQuality} />
                                            </div>
                                            <div className="control-chip">
                                                <span className="chip-label">比例</span>
                                                <Segmented block size="small" options={[{ label: '自动', value: 'auto' }, '1:1', '3:4', '4:3', '9:16', '16:9']} value={aspectRatio} onChange={setAspectRatio} />
                                            </div>
                                            <div className="control-chip">
                                                <span className="chip-label">平台</span>
                                                <Segmented block size="small" options={['通用', '亚马', '虾皮', '抖音', '淘宝', '京东']} value={platform} onChange={setPlatform} />
                                            </div>
                                            <div className="control-chip">
                                                <span className="chip-label">类型</span>
                                                <Segmented block size="small" options={[{ label: '主图', value: '商品主图' }, { label: '详情', value: '详情图' }, { label: '白底', value: '白底图' }, { label: '场景', value: '场景图' }]} value={imageType} onChange={setImageType} />
                                            </div>
                                            <div className="control-chip">
                                                <span className="chip-label">风格</span>
                                                <Segmented block size="small" options={['自动', '简约', '高端', '科技', '温馨']} value={imageStyle} onChange={setImageStyle} />
                                            </div>
                                            <div className="control-chip">
                                                <span className="chip-label">背景</span>
                                                <Segmented block size="small" options={[{ label: '智能', value: '智能推荐' }, '纯色', '渐变', '场景']} value={backgroundType} onChange={setBackgroundType} />
                                            </div>
                                            <div className="control-chip">
                                                <span className="chip-label">语言</span>
                                                <Segmented block size="small" options={[{ label: '简', value: 'zh-CN' }, { label: '繁', value: 'zh-TW' }, 'EN', 'JP']} value={imageLanguage} onChange={setImageLanguage} />
                                            </div>
                                        </div>

                                        <div className="control-section-title">智能分析</div>
                                        <Space size="small" wrap>
                                            <Tooltip title="AI 自动分析参考图的风格特征">
                                                <Button icon={<BulbOutlined />} onClick={handleSmartAnnotateRef} disabled={!refImage || !refAnnotationMode} size="middle" ghost>
                                                    分析参考图
                                                </Button>
                                            </Tooltip>
                                            <Tooltip title="AI 自动分析产品图的质量问题">
                                                <Button icon={<ExperimentOutlined />} onClick={handleSmartAnnotateProd} disabled={!prodImage || !prodAnnotationMode} size="middle" ghost>
                                                    分析产品图
                                                </Button>
                                            </Tooltip>
                                            <Tooltip title="AI 自动检查生成结果的问题">
                                                <Button icon={<BulbOutlined />} onClick={handleSmartAnnotateResult} disabled={!resultImage || !annotationMode} size="middle" ghost>
                                                    分析生成结果
                                                </Button>
                                            </Tooltip>
                                        </Space>

                                        <div className="control-section-title">操作</div>
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, minmax(0, 1fr))', gap: '10px' }}>
                                            <Button type="primary" size="large" icon={<BulbOutlined />} onClick={() => startGuidedFlow({ goal: (studioQuery || '').trim() })} block style={{ gridColumn: '1 / span 2' }}>
                                                AI 引导生成
                                            </Button>
                                            <Button icon={<ThunderboltOutlined />} onClick={handleGenerate} loading={isGenerating} size="middle" block>
                                                快速生成
                                            </Button>
                                            <Button icon={<EyeOutlined />} onClick={handlePreview} loading={isPreviewing} size="middle" block>
                                                预览
                                            </Button>
                                            <Button icon={<UnorderedListOutlined />} onClick={handleAddToQueue} size="middle" block style={{ gridColumn: '1 / span 2' }}>
                                                加入队列
                                            </Button>
                                        </div>
                                        {resultImage && (
                                            <Button icon={<DownloadOutlined />} onClick={handleDownload} size="middle" block>
                                                下载
                                            </Button>
                                        )}
                                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, minmax(0, 1fr))', gap: '10px', marginTop: '10px' }}>
                                            <Button icon={<AppstoreOutlined />} onClick={handleBatchImportClick} size="middle" block>
                                                批量导入
                                            </Button>
                                            <Button icon={<DeleteOutlined />} onClick={handleClearBatch} size="middle" danger block>
                                                清空批量
                                            </Button>
                                        </div>
                                    </Card>
                                    <div className="terminal" id="terminal">
                                        <div className="terminal-line log-info">
                                            <span style={{ opacity: 0.5 }}>[{new Date().toLocaleTimeString()}]</span> [System] 单图创作模式已就绪。
                                        </div>
                                    </div>
                                </div>
                                )}

                                <div style={{ position: 'relative', display: 'flex', flexDirection: 'column', height: '100%' }}>
                                    <div className="studio-leftdock" onMouseDown={(e) => e.stopPropagation()} onWheel={(e) => e.stopPropagation()}>
                                        <div className="dock-surface">
                                            {/* === 导入工具组 === */}
                                            <Tooltip title={prodImage ? '替换产品图' : '上传产品图（可选）'}>
                                                <Upload beforeUpload={handleProdUpload} showUploadList={false} accept="image/*">
                                                    <Button className={'dock-btn ' + (prodImage ? 'active' : '')} icon={<ShoppingOutlined />} />
                                                </Upload>
                                            </Tooltip>
                                            <Tooltip title={refImage ? '替换参考图' : '上传参考图（可选）'}>
                                                <Upload beforeUpload={handleRefUpload} showUploadList={false} accept="image/*">
                                                    <Button className={'dock-btn ' + (refImage ? 'active' : '')} icon={<FileImageOutlined />} />
                                                </Upload>
                                            </Tooltip>
                                            <Tooltip title="添加素材（可多选）">
                                                <Button
                                                    className={'dock-btn ' + (((nodes || []).some(n => n.type === 'batch' && n.src) || (stagedAssets || []).length > 0) ? 'active' : '')}
                                                    icon={<PlusOutlined />}
                                                    onClick={handleBatchImportClick}
                                                />
                                            </Tooltip>

                                            <div className="dock-sep" />

                                            {/* === 画布工具组 === */}
                                            <Tooltip title="抓手工具 (按住空格+拖拽 或 鼠标中键拖拽)">
                                                <Button
                                                    className={'dock-btn ' + (spaceHeld ? 'active' : '')}
                                                    icon={<DragOutlined />}
                                                    onMouseDown={() => setSpaceHeld(true)}
                                                    onMouseUp={() => setSpaceHeld(false)}
                                                    onMouseLeave={() => {}}
                                                />
                                            </Tooltip>
                                            <Tooltip title="添加画板">
                                                <Button className="dock-btn" icon={<BorderOutlined />} onClick={handleAddBoard} />
                                            </Tooltip>
                                            <Tooltip title="适配视图">
                                                <Button className="dock-btn" icon={<FullscreenOutlined />} onClick={handleFitView} disabled={(nodes || []).length === 0} />
                                            </Tooltip>

                                            <div className="dock-sep" />

                                            {/* === 编辑工具组 === */}
                                            <Tooltip title="撤销 (Ctrl+Z)">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<UndoOutlined />}
                                                    onClick={handleUndo}
                                                    disabled={historyIndex <= 0}
                                                />
                                            </Tooltip>
                                            <Tooltip title="重做 (Ctrl+Y)">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<RedoOutlined />}
                                                    onClick={handleRedo}
                                                    disabled={historyIndex >= history.length - 1}
                                                />
                                            </Tooltip>
                                            <Tooltip title="复制选中 (Ctrl+C)">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<CopyOutlined />}
                                                    onClick={handleCopy}
                                                    disabled={selectedNodeIds.length === 0}
                                                />
                                            </Tooltip>
                                            <Tooltip title="粘贴 (Ctrl+V)">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<PicCenterOutlined />}
                                                    onClick={handlePaste}
                                                    disabled={clipboard.length === 0}
                                                />
                                            </Tooltip>
                                            <Tooltip title="删除选中 (Delete)">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<DeleteOutlined />}
                                                    onClick={() => handleDeleteNodes()}
                                                    disabled={selectedNodeIds.length === 0}
                                                    danger
                                                />
                                            </Tooltip>

                                            <div className="dock-sep" />

                                            {/* === 对齐工具组 (多选时显示) === */}
                                            {selectedNodeIds.length >= 2 && (
                                                <>
                                                    <Tooltip title="左对齐">
                                                        <Button className="dock-btn" icon={<AlignLeftOutlined />} onClick={() => handleAlign('left')} />
                                                    </Tooltip>
                                                    <Tooltip title="水平居中">
                                                        <Button className="dock-btn" icon={<AlignCenterOutlined />} onClick={() => handleAlign('center-h')} />
                                                    </Tooltip>
                                                    <Tooltip title="右对齐">
                                                        <Button className="dock-btn" icon={<AlignRightOutlined />} onClick={() => handleAlign('right')} />
                                                    </Tooltip>
                                                    <Tooltip title="水平分布">
                                                        <Button className="dock-btn" icon={<ColumnWidthOutlined />} onClick={() => handleDistribute('horizontal')} disabled={selectedNodeIds.length < 3} />
                                                    </Tooltip>
                                                    <div className="dock-sep" />
                                                </>
                                            )}

                                            {/* === 导出工具组 === */}
                                            <Tooltip title="导出画布">
                                                <Button className="dock-btn" icon={<DownloadOutlined />} onClick={handleExportFullBoard} disabled={(nodes || []).filter(n => getNodeDataUrl(n)).length === 0} />
                                            </Tooltip>
                                            <Tooltip title="清空画布">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<ClearOutlined />}
                                                    onClick={() => {
                                                        Modal.confirm({
                                                            title: '确认清空画布？',
                                                            content: '此操作将清除所有节点，但不会删除已上传的产品图和参考图。',
                                                            okText: '确定',
                                                            cancelText: '取消',
                                                            onOk: () => {
                                                                pushHistory(nodesRef.current);
                                                                setNodes([]);
                                                                setSelectedNodeIds([]);
                                                                setSelectedNode(null);
                                                                message.success('画布已清空');
                                                            }
                                                        });
                                                    }}
                                                    disabled={(nodes || []).length === 0}
                                                />
                                            </Tooltip>

                                            <div className="dock-sep" />

                                            {/* === 网格吸附开关 === */}
                                            <Tooltip title={gridSnapEnabled ? '关闭网格吸附' : '开启网格吸附'}>
                                                <Button
                                                    className={'dock-btn ' + (gridSnapEnabled ? 'active' : '')}
                                                    icon={<BorderOuterOutlined />}
                                                    onClick={() => setGridSnapEnabled(v => !v)}
                                                />
                                            </Tooltip>

                                            {/* === 标尺开关 === */}
                                            <Tooltip title={rulerVisible ? '隐藏标尺' : '显示标尺'}>
                                                <Button
                                                    className={'dock-btn ' + (rulerVisible ? 'active' : '')}
                                                    icon={<ColumnWidthOutlined />}
                                                    onClick={() => setRulerVisible(v => !v)}
                                                />
                                            </Tooltip>

                                            {/* === 锁定/解锁按钮 === */}
                                            <Tooltip title={selectedNodeIds.length > 0 && selectedNodeIds.every(id => lockedNodeIds.includes(id)) ? '解锁选中节点 (Ctrl+L)' : '锁定选中节点 (Ctrl+L)'}>
                                                <Button
                                                    className={'dock-btn ' + (selectedNodeIds.length > 0 && selectedNodeIds.some(id => lockedNodeIds.includes(id)) ? 'active' : '')}
                                                    icon={selectedNodeIds.length > 0 && selectedNodeIds.every(id => lockedNodeIds.includes(id)) ? <UnlockOutlined /> : <LockOutlined />}
                                                    onClick={handleToggleLock}
                                                    disabled={selectedNodeIds.length === 0}
                                                />
                                            </Tooltip>

                                            {/* === 编组按钮 === */}
                                            <Tooltip title="编组选中节点 (Ctrl+G)">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<GroupOutlined />}
                                                    onClick={handleGroupNodes}
                                                    disabled={selectedNodeIds.length < 2}
                                                />
                                            </Tooltip>

                                            {/* === 批量调整大小 === */}
                                            {selectedNodeIds.length > 0 && (
                                                <Dropdown
                                                    trigger={['click']}
                                                    placement="bottomLeft"
                                                    dropdownRender={() => (
                                                        <div style={{
                                                            background: 'var(--bg-elevated)',
                                                            border: '1px solid var(--border-color)',
                                                            borderRadius: 8,
                                                            padding: 12,
                                                            minWidth: 200
                                                        }}>
                                                            <div style={{ fontSize: 13, fontWeight: 600, marginBottom: 10, color: 'var(--text-primary)' }}>
                                                                批量调整宽度
                                                            </div>
                                                            <div style={{ display: 'flex', gap: 8, marginBottom: 10 }}>
                                                                {[150, 200, 280, 400].map(w => (
                                                                    <Button
                                                                        key={w}
                                                                        size="small"
                                                                        onClick={() => handleBatchResize(w)}
                                                                    >
                                                                        {w}
                                                                    </Button>
                                                                ))}
                                                            </div>
                                                            <div style={{ display: 'flex', gap: 8 }}>
                                                                <InputNumber
                                                                    placeholder="自定义宽度"
                                                                    min={80}
                                                                    max={1200}
                                                                    size="small"
                                                                    style={{ flex: 1 }}
                                                                    onPressEnter={(e) => {
                                                                        const val = parseInt(e.target.value);
                                                                        if (val >= 80 && val <= 1200) {
                                                                            handleBatchResize(val);
                                                                        }
                                                                    }}
                                                                />
                                                                <Button
                                                                    size="small"
                                                                    type="primary"
                                                                    onClick={() => {
                                                                        const input = document.querySelector('.batch-resize-input');
                                                                        if (input) {
                                                                            const val = parseInt(input.value);
                                                                            if (val >= 80 && val <= 1200) {
                                                                                handleBatchResize(val);
                                                                            }
                                                                        }
                                                                    }}
                                                                >
                                                                    应用
                                                                </Button>
                                                            </div>
                                                        </div>
                                                    )}
                                                >
                                                    <Button
                                                        className="dock-btn"
                                                        icon={<ColumnHeightOutlined />}
                                                    />
                                                </Dropdown>
                                            )}

                                            <div className="dock-sep" />

                                            {/* === 图层面板 === */}
                                            <Tooltip title="图层面板">
                                                <Button
                                                    className={'dock-btn ' + (layerPanelOpen ? 'active' : '')}
                                                    icon={<OrderedListOutlined />}
                                                    onClick={() => setLayerPanelOpen(v => !v)}
                                                />
                                            </Tooltip>

                                            {/* === AI 面板 === */}
                                            <Tooltip title={aiPanelOpen ? '收起 AI 面板' : '展开 AI 面板'}>
                                                <Button
                                                    className={'dock-btn ' + ((aiPanelOpen || guidedStage !== 'idle') ? 'active' : '')}
                                                    icon={<RobotOutlined />}
                                                    onClick={() => setAiPanelOpen(v => !v)}
                                                />
                                            </Tooltip>

                                            <div className="dock-sep" />

                                            {/* === 帮助 === */}
                                            <Tooltip title="快捷键帮助 (?)">
                                                <Button
                                                    className="dock-btn"
                                                    icon={<QuestionCircleOutlined />}
                                                    onClick={() => setHelpModalOpen(true)}
                                                />
                                            </Tooltip>
                                        </div>
                                    </div>
                                    <div
                                        className={'canvas-viewport ' + (isPanning ? 'panning ' : '') + (spaceHeld ? 'space-held' : '')}
                                        style={{ flex: 1, minHeight: '500px' }}
                                        onWheel={handleWheel}
                                        onDragStart={handleCanvasDragStart}
                                        onDragOver={handleStudioDragOver}
                                        onDragLeave={handleStudioDragLeave}
                                        onDrop={handleStudioDrop}
                                        onMouseDown={handleCanvasMouseDown}
                                        onMouseMove={handleCanvasMouseMove}
                                        onMouseUp={handleCanvasMouseUp}
                                        onMouseLeave={handleCanvasMouseUp}
                                        onContextMenu={(e) => handleContextMenu(e, null)}
                                        ref={canvasRef}
                                    >
                                        {/* 画布标尺 */}
                                        {rulerVisible && (
                                            <>
                                                {/* 水平标尺 */}
                                                <div className="canvas-ruler canvas-ruler-h">
                                                    {rulerTicks.horizontal.map((tick, i) => (
                                                        <React.Fragment key={`h-${i}`}>
                                                            <div
                                                                className="ruler-tick-line-h"
                                                                style={{
                                                                    left: tick.pos,
                                                                    height: tick.major ? 10 : 5
                                                                }}
                                                            />
                                                            {tick.major && (
                                                                <span
                                                                    className="ruler-tick ruler-tick-h"
                                                                    style={{ left: tick.pos }}
                                                                >
                                                                    {tick.label}
                                                                </span>
                                                            )}
                                                        </React.Fragment>
                                                    ))}
                                                </div>
                                                {/* 垂直标尺 */}
                                                <div className="canvas-ruler canvas-ruler-v">
                                                    {rulerTicks.vertical.map((tick, i) => (
                                                        <React.Fragment key={`v-${i}`}>
                                                            <div
                                                                className="ruler-tick-line-v"
                                                                style={{
                                                                    top: tick.pos,
                                                                    width: tick.major ? 10 : 5
                                                                }}
                                                            />
                                                            {tick.major && (
                                                                <span
                                                                    className="ruler-tick ruler-tick-v"
                                                                    style={{ top: tick.pos }}
                                                                >
                                                                    {tick.label}
                                                                </span>
                                                            )}
                                                        </React.Fragment>
                                                    ))}
                                                </div>
                                                {/* 左上角 */}
                                                <Tooltip title={rulerVisible ? '隐藏标尺' : '显示标尺'}>
                                                    <div
                                                        className="canvas-ruler-corner"
                                                        onClick={() => setRulerVisible(v => !v)}
                                                        style={{ pointerEvents: 'auto' }}
                                                    >
                                                        <span style={{ fontSize: 10, color: 'var(--text-tertiary)' }}>px</span>
                                                    </div>
                                                </Tooltip>
                                            </>
                                        )}
                                        <div
                                            className="canvas-content"
                                            ref={canvasContentRef}
                                            style={{ width: '100%', height: '100%' }}
                                            onMouseMove={handleNodeMouseMove}
                                            onMouseUp={handleNodeMouseUp}
                                        >
                                            <div className="canvas-grid" />
                                            {/* 对齐辅助线 */}
                                            {alignLines.v.map((x, i) => (
                                                <div
                                                    key={`v-${i}`}
                                                    className="align-line align-line-v"
                                                    style={{
                                                        position: 'absolute',
                                                        left: x,
                                                        top: -10000,
                                                        width: 1,
                                                        height: 20000,
                                                        background: '#1890ff',
                                                        pointerEvents: 'none',
                                                        zIndex: 1000
                                                    }}
                                                />
                                            ))}
                                            {alignLines.h.map((y, i) => (
                                                <div
                                                    key={`h-${i}`}
                                                    className="align-line align-line-h"
                                                    style={{
                                                        position: 'absolute',
                                                        left: -10000,
                                                        top: y,
                                                        width: 20000,
                                                        height: 1,
                                                        background: '#1890ff',
                                                        pointerEvents: 'none',
                                                        zIndex: 1000
                                                    }}
                                                />
                                            ))}
                                            {nodes.map(node => (
                                                <div
                                                    key={node.id}
                                                    ref={setNodeEl(node.id)}
                                                    className={'draggable-node ' + (selectedNodeIds.includes(node.id) ? 'selected ' : '') + ((isDraggingNode && selectedNodeIds.includes(node.id)) ? 'dragging ' : '') + (node.type === 'batch' ? 'node-batch' : '')}
                                                    style={{ width: node.width }}
                                                    onMouseDown={(e) => handleNodeMouseDown(e, node.id)}
                                                    onWheel={(e) => handleNodeWheel(e, node.id)}
                                                    onContextMenu={(e) => handleContextMenu(e, node.id)}
                                                    onDoubleClick={(e) => handleNodeDoubleClick(e, node.id)}
                                                >
                                                    <div className="node-header">
                                                        <span>
                                                            {lockedNodeIds.includes(node.id) && <LockOutlined style={{ marginRight: 4, color: '#faad14' }} />}
                                                            {node.groupId && <span style={{ marginRight: 4, color: '#1890ff' }}>●</span>}
                                                            {node.type === 'reference' && <><FileImageOutlined /> 参考主图</>}
                                                            {node.type === 'product' && <><ShoppingOutlined /> 我的产品</>}
                                                            {node.type === 'result' && <><PictureOutlined /> 生成结果</>}
                                                            {node.type === 'batch' && <><AppstoreOutlined /> 批量素材</>}
                                                            {node.type === 'board' && <><BorderOutlined /> 画板</>}
                                                        </span>
                                                        {node.type === 'reference' && refImage && (
                                                            <Switch
                                                                checkedChildren="标注开关"
                                                                unCheckedChildren="标注"
                                                                checked={refAnnotationMode}
                                                                onChange={handleToggleRefAnnotation}
                                                                size="small"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                        )}
                                                        {node.type === 'product' && prodImage && (
                                                            <Switch
                                                                checkedChildren="标注开关"
                                                                unCheckedChildren="标注"
                                                                checked={prodAnnotationMode}
                                                                onChange={handleToggleProdAnnotation}
                                                                size="small"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            />
                                                        )}
                                                        {node.type === 'result' && (
                                                            <Switch
                                                                checkedChildren="标注模式"
                                                                unCheckedChildren="标注模式"
                                                                checked={annotationMode}
                                                                onChange={handleToggleAnnotation}
                                                                size="small"
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                                disabled={!resultImage}
                                                            />
                                                        )}
                                                    </div>
                                                    <div className="node-content">
                                                        {node.type === 'board' && (() => {
                                                            const aspect = (node.aspect && isFinite(node.aspect) && node.aspect > 0) ? node.aspect : 1;
                                                            const width = Number(node.width || 0);
                                                            const height = Math.max(220, width / aspect);
                                                            return (
                                                                <div className="board-frame" style={{ height }}>
                                                                    <div className="board-hint">
                                                                        <div style={{ fontWeight: 700, marginBottom: 6 }}>空白画板</div>
                                                                        <div style={{ opacity: 0.7 }}>可拖拽、可缩放，用于排版与导出</div>
                                                                    </div>
                                                                    <div className="resize-handle" onMouseDown={(e) => handleResizeMouseDown(e, node.id)}>⇲</div>
                                                                </div>
                                                            );
                                                        })()}

                                                        {node.type === 'batch' && (
                                                            <div style={{ width: '100%', borderRadius: '0px', overflow: 'visible', position: 'relative' }}>
                                                                {node.src ? (
                                                                    <img src={node.src} onLoad={handleNodeImageLoad(node.id)} draggable={false} onDragStart={(e) => e.preventDefault()} />
                                                                ) : (
                                                                    <div className="ghost-drop" style={{ padding: '22px 0', textAlign: 'center', width: '100%' }}>
                                                                        <FileImageOutlined style={{ fontSize: '42px', color: 'var(--text-tertiary)' }} />
                                                                        <p style={{ marginTop: '8px', color: 'var(--text-secondary)' }}>等待导入...</p>
                                                                    </div>
                                                                )}
                                                                {node.src && (
                                                                    <div className="resize-handle" onMouseDown={(e) => handleResizeMouseDown(e, node.id)}>⇲</div>
                                                                )}
                                                            </div>
                                                        )}
                                                        {node.type === 'reference' && (
                                                            <div id="ref-image-container" style={{ width: '100%', borderRadius: '0px', overflow: 'visible', minHeight: refImage ? undefined : '280px', position: 'relative' }}>
                                                                <Dragger
                                                                    beforeUpload={handleRefUpload}
                                                                    showUploadList={false}
                                                                    accept="image/*"
                                                                    disabled={!!refImage}
                                                                    style={{
                                                                        width: '100%',
                                                                        background: 'transparent',
                                                                        border: 'none',
                                                                        pointerEvents: refImage ? 'none' : 'auto'
                                                                    }}
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                >
                                                                    {refImage ? (
                                                                        <div style={{ width: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
                                                                            <img src={refImage} onLoad={handleNodeImageLoad('ref')} draggable={false} onDragStart={(e) => e.preventDefault()} />
                                                                        </div>
                                                                    ) : (
                                                                        <div className="ghost-drop" style={{ padding: '26px 0', textAlign: 'center' }}>
                                                                            <FileImageOutlined style={{ fontSize: '42px', color: 'var(--text-tertiary)' }} />
                                                                            <p style={{ marginTop: '8px', color: 'var(--text-secondary)' }}>点击或拖拽上传</p>
                                                                        </div>
                                                                    )}
                                                                </Dragger>
                                                                {refImage && (
                                                                    <div className="resize-handle" onMouseDown={(e) => handleResizeMouseDown(e, node.id)}>⇲</div>
                                                                )}
                                                            </div>
                                                        )}
                                                        {node.type === 'product' && (
                                                            <div id="prod-image-container" style={{ width: '100%', borderRadius: '0px', overflow: 'visible', minHeight: prodImage ? undefined : '280px', position: 'relative' }}>
                                                                <Dragger
                                                                    beforeUpload={handleProdUpload}
                                                                    showUploadList={false}
                                                                    accept="image/*"
                                                                    disabled={!!prodImage}
                                                                    style={{
                                                                        width: '100%',
                                                                        background: 'transparent',
                                                                        border: 'none',
                                                                        pointerEvents: prodImage ? 'none' : 'auto'
                                                                    }}
                                                                    onMouseDown={(e) => e.stopPropagation()}
                                                                >
                                                                    {prodImage ? (
                                                                        <div style={{ width: '100%', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
                                                                            <img src={prodImage} onLoad={handleNodeImageLoad('prod')} draggable={false} onDragStart={(e) => e.preventDefault()} />
                                                                        </div>
                                                                    ) : (
                                                                        <div className="ghost-drop" style={{ padding: '26px 0', textAlign: 'center' }}>
                                                                            <ShoppingOutlined style={{ fontSize: '42px', color: 'var(--text-tertiary)' }} />
                                                                            <p style={{ marginTop: '8px', color: 'var(--text-secondary)' }}>点击或拖拽上传</p>
                                                                        </div>
                                                                    )}
                                                                </Dragger>
                                                                {prodImage && (
                                                                    <div className="resize-handle" onMouseDown={(e) => handleResizeMouseDown(e, node.id)}>⇲</div>
                                                                )}
                                                            </div>
                                                        )}
                                                        {node.type === 'result' && (
                                                            <div id="single-result" style={{ width: '100%', borderRadius: '0px', overflow: 'visible', minHeight: resultImage ? undefined : '320px', display: 'flex', alignItems: 'center', justifyContent: 'center', position: 'relative' }}>
                                                                {resultImage ? (
                                                                    <img src={resultImage} onLoad={handleNodeImageLoad('result')} draggable={false} onDragStart={(e) => e.preventDefault()} />
                                                                ) : (
                                                                    <div className="ghost-drop" style={{ padding: '22px 0', textAlign: 'center', width: '100%' }}>
                                                                        <PictureOutlined style={{ fontSize: '42px', color: 'var(--text-tertiary)' }} />
                                                                        <p style={{ marginTop: '8px', color: 'var(--text-secondary)' }}>等待生成...</p>
                                                                    </div>
                                                                )}
                                                                {resultImage && (
                                                                    <div className="resize-handle" onMouseDown={(e) => handleResizeMouseDown(e, node.id)}>⇲</div>
                                                                )}
                                                            </div>
                                                        )}
                                                    </div>
                                                    {node.type === 'result' && annotationMode && (
                                                        <div style={{ padding: '0 16px 16px' }}>
                                                            <Space size="small">
                                                                <Button size="small" onClick={handleSubmitAnnotations} onMouseDown={(e) => e.stopPropagation()}>提交修改</Button>
                                                                <Button size="small" onClick={handleClearAnnotations} onMouseDown={(e) => e.stopPropagation()}>清空标注</Button>
                                                            </Space>
                                                        </div>
                                                    )}
                                                </div>
                                            ))}
                                        </div>
                                        {marquee && (
                                            <div
                                                className="marquee-rect"
                                                style={{
                                                    left: Math.min(marquee.x1, marquee.x2),
                                                    top: Math.min(marquee.y1, marquee.y2),
                                                    width: Math.abs(marquee.x2 - marquee.x1),
                                                    height: Math.abs(marquee.y2 - marquee.y1)
                                                }}
                                            />
                                        )}

                                        {/* 右键菜单 */}
                                        {contextMenu && (
                                            <div
                                                className="context-menu"
                                                style={{
                                                    position: 'fixed',
                                                    left: contextMenu.x,
                                                    top: contextMenu.y,
                                                    zIndex: 9999,
                                                    background: '#1f1f1f',
                                                    border: '1px solid #424242',
                                                    borderRadius: '8px',
                                                    boxShadow: '0 6px 16px 0 rgba(0,0,0,0.4)',
                                                    padding: '4px 0',
                                                    minWidth: '160px'
                                                }}
                                                onClick={(e) => e.stopPropagation()}
                                            >
                                                {contextMenuItems.map((item, idx) => {
                                                    if (item.type === 'divider') {
                                                        return <div key={idx} style={{ borderTop: '1px solid #424242', margin: '4px 0' }} />;
                                                    }
                                                    return (
                                                        <div
                                                            key={item.key}
                                                            className={`context-menu-item ${item.disabled ? 'disabled' : ''} ${item.danger ? 'danger' : ''}`}
                                                            style={{
                                                                padding: '8px 12px',
                                                                cursor: item.disabled ? 'not-allowed' : 'pointer',
                                                                display: 'flex',
                                                                alignItems: 'center',
                                                                gap: '8px',
                                                                color: item.disabled ? '#666' : item.danger ? '#ff4d4f' : '#fff',
                                                                opacity: item.disabled ? 0.5 : 1,
                                                                transition: 'background 0.15s'
                                                            }}
                                                            onMouseEnter={(e) => {
                                                                if (!item.disabled) e.currentTarget.style.background = 'rgba(255,255,255,0.1)';
                                                            }}
                                                            onMouseLeave={(e) => {
                                                                e.currentTarget.style.background = 'transparent';
                                                            }}
                                                            onClick={() => {
                                                                if (!item.disabled && item.onClick) {
                                                                    item.onClick();
                                                                    closeContextMenu();
                                                                }
                                                            }}
                                                        >
                                                            {item.icon}
                                                            <span>{item.label}</span>
                                                        </div>
                                                    );
                                                })}
                                            </div>
                                        )}

                                        {selectionScreenRect && (
                                            <div
                                                className="selection-toolbar"
                                                style={{ left: selectionScreenRect.cx, top: Math.max(12, selectionScreenRect.y - 12) }}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            >
                                                <Space size="small" wrap>
                                                    <Tooltip title="删除 (Delete)">
                                                        <Button size="small" icon={<DeleteOutlined />} danger onClick={() => handleDeleteNodes()}>
                                                            删除
                                                        </Button>
                                                    </Tooltip>
                                                    <Tooltip title="复制 (Ctrl+C)">
                                                        <Button size="small" icon={<CopyOutlined />} onClick={handleCopy}>
                                                            复制
                                                        </Button>
                                                    </Tooltip>
                                                    <Button size="small" icon={<DownloadOutlined />} onClick={handleDownloadSelection}>
                                                        {selectedNodeIds.length === 1 ? '下载' : `下载选中(${selectedNodeIds.length})`}
                                                    </Button>
                                                    {selectedNodeIds.length > 1 && (
                                                        <Button size="small" icon={<DownloadOutlined />} onClick={handleExportSelectionBoard}>
                                                            导出选区
                                                        </Button>
                                                    )}
                                                    <Button size="small" icon={<DownloadOutlined />} onClick={handleExportFullBoard}>
                                                        导出画布
                                                    </Button>
                                                    {selectedNodeIds.length === 1 && (
                                                        <>
                                                            <Button size="small" icon={<ShoppingOutlined />} onClick={() => applyNodeAsProduct(selectedNodeIds[0])}>
                                                                设为产品
                                                            </Button>
                                                            <Button size="small" icon={<FileImageOutlined />} onClick={() => applyNodeAsReference(selectedNodeIds[0])}>
                                                                设为参考
                                                            </Button>
                                                        </>
                                                    )}
                                                    {selectedNodeIds.length >= 2 && (
                                                        <>
                                                            <Divider type="vertical" style={{ margin: '0 2px', borderColor: 'var(--border-color)' }} />
                                                            <Tooltip title="左对齐">
                                                                <Button size="small" icon={<AlignLeftOutlined />} onClick={() => handleAlign('left')} />
                                                            </Tooltip>
                                                            <Tooltip title="水平居中">
                                                                <Button size="small" icon={<AlignCenterOutlined />} onClick={() => handleAlign('center-h')} />
                                                            </Tooltip>
                                                            <Tooltip title="右对齐">
                                                                <Button size="small" icon={<AlignRightOutlined />} onClick={() => handleAlign('right')} />
                                                            </Tooltip>
                                                            <Tooltip title="顶对齐">
                                                                <Button size="small" icon={<VerticalAlignTopOutlined />} onClick={() => handleAlign('top')} />
                                                            </Tooltip>
                                                            <Tooltip title="垂直居中">
                                                                <Button size="small" icon={<VerticalAlignMiddleOutlined />} onClick={() => handleAlign('center-v')} />
                                                            </Tooltip>
                                                            <Tooltip title="底对齐">
                                                                <Button size="small" icon={<VerticalAlignBottomOutlined />} onClick={() => handleAlign('bottom')} />
                                                            </Tooltip>
                                                        </>
                                                    )}
                                                </Space>
                                            </div>
                                        )}

                                        {(nodes || []).length > 0 && (
                                            <div className="zoom-controls">
                                                <Tooltip title="撤销 (Ctrl+Z)">
                                                    <button onClick={handleUndo} disabled={historyIndex <= 0} style={{ opacity: historyIndex <= 0 ? 0.4 : 1 }}><UndoOutlined /></button>
                                                </Tooltip>
                                                <Tooltip title="重做 (Ctrl+Y)">
                                                    <button onClick={handleRedo} disabled={historyIndex >= history.length - 1} style={{ opacity: historyIndex >= history.length - 1 ? 0.4 : 1 }}><RedoOutlined /></button>
                                                </Tooltip>
                                                <Divider type="vertical" style={{ margin: '0 4px', borderColor: 'var(--border-color)' }} />
                                                <button onClick={handleZoomOut} title="缩小">-</button>
                                                <span className="zoom-value" onClick={handleZoomReset} style={{ cursor: 'pointer' }} title="重置缩放">{Math.round(viewport.scale * 100)}%</span>
                                                <button onClick={handleZoomIn} title="放大">+</button>
                                                <Divider type="vertical" style={{ margin: '0 4px', borderColor: 'var(--border-color)' }} />
                                                <button onClick={handleFitView} title="适应画布" style={{ fontSize: '12px' }}><FullscreenOutlined /></button>
                                                <Divider type="vertical" style={{ margin: '0 4px', borderColor: 'var(--border-color)' }} />
                                                <Tooltip title={minimapVisible ? '隐藏小地图' : '显示小地图'}>
                                                    <button onClick={() => setMinimapVisible(v => !v)} style={{ fontSize: '12px', opacity: minimapVisible ? 1 : 0.5 }}><AppstoreOutlined /></button>
                                                </Tooltip>
                                            </div>
                                        )}

                                        {/* 小地图 */}
                                        {minimapVisible && minimapData && (nodes || []).length > 0 && (
                                            <div
                                                className="canvas-minimap"
                                                style={{
                                                    position: 'absolute',
                                                    right: 16,
                                                    bottom: 16,
                                                    width: minimapData.width,
                                                    height: minimapData.height,
                                                    background: 'rgba(0,0,0,0.6)',
                                                    border: '1px solid rgba(255,255,255,0.2)',
                                                    borderRadius: 8,
                                                    overflow: 'hidden',
                                                    cursor: 'pointer',
                                                    zIndex: 100
                                                }}
                                                onClick={handleMinimapClick}
                                                onMouseDown={(e) => e.stopPropagation()}
                                            >
                                                {minimapData.nodes.map(n => (
                                                    <div
                                                        key={n.id}
                                                        style={{
                                                            position: 'absolute',
                                                            left: n.x,
                                                            top: n.y,
                                                            width: Math.max(2, n.w),
                                                            height: Math.max(2, n.h),
                                                            background: n.type === 'product' ? '#52c41a' :
                                                                        n.type === 'reference' ? '#1890ff' :
                                                                        n.type === 'result' ? '#722ed1' :
                                                                        'rgba(255,255,255,0.5)',
                                                            borderRadius: 1
                                                        }}
                                                    />
                                                ))}
                                                <div style={{
                                                    position: 'absolute',
                                                    bottom: 2,
                                                    right: 4,
                                                    fontSize: 9,
                                                    opacity: 0.5,
                                                    color: '#fff'
                                                }}>
                                                    {(nodes || []).length} 节点
                                                </div>
                                            </div>
                                        )}

                                        {/* Studio Command Bar */}
                                        <div className={'studio-commandbar ' + ((!resultImage && guidedStage === 'idle') ? 'initial ' : '') + (studioDragActive ? 'drag-active' : '')}>
                                            {resultImage && (
                                            <div className="asset-indicators">
                                                <Tooltip title={prodImage ? '点击替换产品图' : '点击上传产品图（必填）'}>
                                                    <Upload beforeUpload={handleProdUpload} showUploadList={false} accept="image/*">
                                                        <div className={'asset-chip ' + (prodImage ? 'active' : '')} style={{ cursor: 'pointer' }}>
                                                            <span className="dot" />
                                                            产品
                                                        </div>
                                                    </Upload>
                                                </Tooltip>
                                                <Tooltip title={refImage ? '点击替换参考图' : '点击上传参考图（可选）'}>
                                                    <Upload beforeUpload={handleRefUpload} showUploadList={false} accept="image/*">
                                                        <div className={'asset-chip ' + (refImage ? 'active' : '')} style={{ cursor: 'pointer' }}>
                                                            <span className="dot" />
                                                            参考
                                                        </div>
                                                    </Upload>
                                                </Tooltip>
                                                <Tooltip title="导入素材（可多选）">
                                                    <div
                                                        className={'asset-chip ' + (((nodes || []).some(n => n.type === 'batch' && n.src) || (stagedAssets || []).length > 0) ? 'active' : '')}
                                                        style={{ cursor: 'pointer' }}
                                                        onClick={handleBatchImportClick}
                                                        role="button"
                                                        tabIndex={0}
                                                        onKeyDown={(e) => {
                                                            if (e.key === 'Enter') handleBatchImportClick();
                                                        }}
                                                    >
                                                        <span className="dot" />
                                                        素材
                                                    </div>
                                                </Tooltip>
                                            </div>
                                            )}
                                                <div className="bar-surface">
                                                    <div className="bar-actions">
                                                    <Tooltip title="添加图片（可多选，也可拖拽到画布）">
                                                        <Button size="middle" icon={<PlusOutlined />} onClick={handleBatchImportClick} />
                                                    </Tooltip>
                                                    </div>

                                                {guidedStage === 'idle' ? (
                                                    <div className="bar-input">
                                                        <Input
                                                            value={studioQuery}
                                                            onChange={(e) => setStudioQuery(e.target.value)}
                                                            onPressEnter={handleStudioSubmit}
                                                            placeholder="描述你的需求，例如：更高级、更干净、换场景、偏某个平台风格…"
                                                            allowClear
                                                            size="middle"
                                                            style={{ background: 'transparent', border: 'none', boxShadow: 'none', paddingLeft: 4, paddingRight: 4 }}
                                                        />
                                                    </div>
                                                ) : (
                                                    <div className="bar-input" style={{ display: 'flex', alignItems: 'center', color: 'var(--text-secondary)', fontSize: 13 }}>
                                                        引导中…在右侧继续
                                                    </div>
                                                )}

                                                <div className="bar-actions">
                                                    <Select
                                                        value={aspectRatio}
                                                        onChange={setAspectRatio}
                                                        options={[
                                                            { label: '比例: 自动', value: 'auto' },
                                                            { label: '1:1', value: '1:1' },
                                                            { label: '3:4', value: '3:4' },
                                                            { label: '4:3', value: '4:3' },
                                                            { label: '9:16', value: '9:16' },
                                                            { label: '16:9', value: '16:9' }
                                                        ]}
                                                        size="middle"
                                                        style={{ width: 130 }}
                                                    />
                                                    <Button
                                                        type="primary"
                                                        icon={<SendOutlined />}
                                                        size="middle"
                                                        onClick={handleStudioSubmit}
                                                    >
                                                        {guidedStage === 'idle' ? '生成' : '继续'}
                                                    </Button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <input ref={batchInputRef} type="file" multiple accept="image/*" style={{ display: 'none' }} onChange={handleBatchInputChange} />
                        </Content>

                        {/* AI Copilot Sidebar */}
                        {(aiPanelOpen || guidedStage !== 'idle' || resultImage) && (
                        <Sider
                            width={380}
                            collapsible
                            collapsedWidth={0}
                            collapsed={!aiPanelOpen}
                            trigger={null}
                            style={{ background: 'var(--bg-secondary)', borderLeft: '1px solid var(--border-color)' }}
                        >
                            <div style={{ height: '100%', display: 'flex', flexDirection: 'column', padding: '16px' }}>
                                <div style={{
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'space-between',
                                    marginBottom: '16px',
                                    padding: '12px 16px',
                                    background: 'var(--bg-tertiary)',
                                    borderRadius: 'var(--radius-l)',
                                    border: '1px solid var(--border-color)'
                                }}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                                        <div style={{
                                            width: '40px',
                                            height: '40px',
                                            background: 'var(--accent-gradient)',
                                            borderRadius: 'var(--radius-m)',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center',
                                            boxShadow: 'var(--shadow-glow)'
                                        }}>
                                            <RobotOutlined style={{ fontSize: '20px', color: 'white' }} />
                                        </div>
                                        <div>
                                            <div style={{ fontWeight: 600, fontSize: '15px' }}>Xobi Copilot</div>
                                            <div style={{ fontSize: '12px', color: 'var(--accent-color)' }}>在线 · 正在为您服务</div>
                                        </div>
                                    </div>
                                    <Space size="small">
                                        <Tooltip title="查看示例">
                                            <Button
                                                size="small"
                                                icon={<BookOutlined />}
                                                onClick={() => setHistoryVisible(true)}
                                                style={{
                                                    background: 'var(--bg-elevated)',
                                                    borderColor: 'var(--border-color)'
                                                }}
                                            />
                                        </Tooltip>
                                        <Tooltip title="收起">
                                            <Button
                                                size="small"
                                                icon={<CloseOutlined />}
                                                onClick={() => setAiPanelOpen(false)}
                                                style={{
                                                    background: 'var(--bg-elevated)',
                                                    borderColor: 'var(--border-color)'
                                                }}
                                            />
                                        </Tooltip>
                                    </Space>
                                </div>

                                <div
                                    ref={chatContainerRef}
                                    style={{
                                        flex: 1,
                                        overflowY: 'auto',
                                        marginBottom: '16px',
                                        background: 'var(--bg-primary)',
                                        borderRadius: 'var(--radius-l)',
                                        padding: '16px',
                                        border: '1px solid var(--border-color)'
                                    }}
                                >
                                    {chatMessages.map((msg, index) => (
                                        <div key={index} style={{
                                            marginBottom: '12px',
                                            display: 'flex',
                                            justifyContent: msg.role === 'user' ? 'flex-end' : 'flex-start',
                                            gap: '10px'
                                        }}>
                                            {msg.role === 'ai' && (
                                                <Avatar
                                                    style={{
                                                        background: 'var(--accent-gradient)',
                                                        flexShrink: 0,
                                                        boxShadow: '0 2px 8px rgba(191, 90, 242, 0.3)'
                                                    }}
                                                    icon={<RobotOutlined />}
                                                />
                                            )}
                                            <div style={{
                                                background: msg.role === 'user' ? 'var(--accent-gradient)' : 'var(--bg-tertiary)',
                                                color: 'white',
                                                padding: '10px 14px',
                                                borderRadius: msg.role === 'user' ? '16px 16px 4px 16px' : '16px 16px 16px 4px',
                                                maxWidth: '75%',
                                                wordBreak: 'break-word',
                                                whiteSpace: 'pre-wrap',
                                                fontSize: '14px',
                                                lineHeight: '1.5',
                                                boxShadow: msg.role === 'user' ? 'var(--shadow-glow)' : 'var(--shadow-sm)'
                                            }}>
                                                {(msg.content || '').trim()}
                                            </div>
                                            {msg.role === 'user' && (
                                                <Avatar
                                                    style={{
                                                        background: 'var(--bg-elevated)',
                                                        color: 'var(--text-primary)',
                                                        flexShrink: 0
                                                    }}
                                                >
                                                    🧑
                                                </Avatar>
                                            )}
                                        </div>
                                    ))}

                                    {/* Guided flow UI (no modal) */}
                                    {guidedStage !== 'idle' && (
                                        <div style={{ marginTop: 14 }}>
                                            {guidedStage === 'qa' && (() => {
                                                const q = (guidedQuestions || [])[guidedQuestionIndex];
                                                if (!q) return null;
                                                const total = (guidedQuestions || []).length || 1;
                                                const index = Math.min(guidedQuestionIndex + 1, total);
                                                return (
                                                    <div style={{
                                                        border: '1px solid var(--border-color)',
                                                        borderRadius: 14,
                                                        background: 'var(--bg-tertiary)',
                                                        padding: 12
                                                    }}>
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 8, marginBottom: 8 }}>
                                                            <div style={{ fontWeight: 700 }}>引导问答</div>
                                                            <Tag color="blue">{index}/{total}</Tag>
                                                        </div>
                                                        <div style={{ fontSize: 12, color: 'var(--text-secondary)', marginBottom: 10 }}>
                                                            {q.prompt}
                                                        </div>
                                                        {q.type === 'choice' ? (
                                                            <Space size="small" wrap>
                                                                {(q.options || []).map((opt) => (
                                                                    <Button
                                                                        key={String(opt.value)}
                                                                        size="small"
                                                                        onClick={() => handleGuidedChooseOption(q, opt)}
                                                                        disabled={guidedLoadingPlan || guidedGenerating}
                                                                    >
                                                                        {opt.label}
                                                                    </Button>
                                                                ))}
                                                            </Space>
                                                        ) : (
                                                            <div style={{ fontSize: 12, color: 'var(--text-secondary)' }}>
                                                                请在下方输入后回车发送。
                                                            </div>
                                                        )}
                                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: 12 }}>
                                                            <Button size="small" onClick={handleGuidedSkipQuestion} disabled={guidedLoadingPlan || guidedGenerating}>
                                                                跳过
                                                            </Button>
                                                            <Space size="small">
                                                                <Button size="small" onClick={handleGuidedExit} disabled={guidedLoadingPlan || guidedGenerating}>
                                                                    退出
                                                                </Button>
                                                                <Button size="small" type="primary" onClick={handleGuidedImmediate} loading={guidedLoadingPlan || guidedGenerating}>
                                                                    立即出图
                                                                </Button>
                                                            </Space>
                                                        </div>
                                                    </div>
                                                );
                                            })()}

                                            {guidedStage === 'plan' && (
                                                <div style={{
                                                    border: '1px solid var(--border-color)',
                                                    borderRadius: 14,
                                                    background: 'var(--bg-tertiary)',
                                                    padding: 12
                                                }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 8, marginBottom: 8 }}>
                                                        <div style={{ fontWeight: 700 }}>计划与方向</div>
                                                        {guidedLoadingPlan ? <Tag color="blue">生成中…</Tag> : <Tag color="blue">就绪</Tag>}
                                                    </div>

                                                    {Array.isArray(guidedPlan) && guidedPlan.length > 0 && (
                                                        <div style={{ display: 'grid', gap: 8, marginBottom: 10 }}>
                                                            {guidedPlan.map((p) => (
                                                                <div
                                                                    key={p.step}
                                                                    style={{
                                                                        border: '1px solid var(--border-color)',
                                                                        borderRadius: 12,
                                                                        background: 'var(--bg-primary)',
                                                                        padding: '8px 10px'
                                                                    }}
                                                                >
                                                                    <div style={{ fontWeight: 600, fontSize: 13 }}>{p.step}. {p.title}</div>
                                                                    <div style={{ marginTop: 4, fontSize: 12, color: 'var(--text-secondary)' }}>{p.detail}</div>
                                                                </div>
                                                            ))}
                                                        </div>
                                                    )}

                                                    <div style={{ display: 'grid', gap: 10 }}>
                                                        {(guidedDirections || []).map((d) => (
                                                            <div
                                                                key={d.id}
                                                                onClick={() => setGuidedSelectedId(d.id)}
                                                                style={{
                                                                    border: guidedSelectedId === d.id ? '1px solid var(--accent-color)' : '1px solid var(--border-color)',
                                                                    borderRadius: 14,
                                                                    background: guidedSelectedId === d.id ? 'rgba(59, 130, 246, 0.12)' : 'var(--bg-primary)',
                                                                    padding: 12,
                                                                    cursor: 'pointer'
                                                                }}
                                                            >
                                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 8 }}>
                                                                    <div style={{ fontWeight: 700 }}>{d.id}. {d.title}</div>
                                                                    <Tag color="blue">{String(d.style_preset || 'generic')}</Tag>
                                                                </div>
                                                                <div style={{ marginTop: 6, fontSize: 12, color: 'var(--text-secondary)' }}>{d.summary}</div>
                                                                <div style={{ marginTop: 10, fontSize: 12, color: 'var(--text-tertiary)' }}>
                                                                    推荐比例：{d.recommended_aspect_ratio || '1:1'}
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>

                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: 12 }}>
                                                        <Button
                                                            size="small"
                                                            onClick={() => { setGuidedStage('qa'); setGuidedQuestionIndex(0); askGuidedQuestion(0, guidedQuestions); }}
                                                            disabled={guidedLoadingPlan || guidedGenerating}
                                                        >
                                                            重新问答
                                                        </Button>
                                                        <Space size="small">
                                                            <Button size="small" onClick={handleGuidedExit} disabled={guidedLoadingPlan || guidedGenerating}>
                                                                退出
                                                            </Button>
                                                            <Button size="small" type="primary" onClick={() => handleGuidedGenerateCandidates().catch(() => { })} loading={guidedGenerating} disabled={guidedLoadingPlan}>
                                                                生成候选
                                                            </Button>
                                                        </Space>
                                                    </div>
                                                </div>
                                            )}

                                            {guidedStage === 'candidates' && (
                                                <div style={{
                                                    border: '1px solid var(--border-color)',
                                                    borderRadius: 14,
                                                    background: 'var(--bg-tertiary)',
                                                    padding: 12
                                                }}>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 8, marginBottom: 8 }}>
                                                        <div style={{ fontWeight: 700 }}>选择最终版本</div>
                                                        <Tag color="blue">{(guidedCandidates || []).length} 张</Tag>
                                                    </div>
                                                    <div style={{ fontSize: 12, color: 'var(--text-secondary)', marginBottom: 10 }}>
                                                        点击「选这张」会把它放到画布里，随后可继续精修。
                                                    </div>
                                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, minmax(0, 1fr))', gap: 10 }}>
                                                        {(guidedCandidates || []).map((c) => (
                                                            <div
                                                                key={c.index}
                                                                style={{
                                                                    border: '1px solid var(--border-color)',
                                                                    borderRadius: 14,
                                                                    overflow: 'hidden',
                                                                    background: 'var(--bg-primary)'
                                                                }}
                                                            >
                                                                <img src={c.dataUrl} style={{ width: '100%', display: 'block' }} draggable={false} />
                                                                <div style={{ display: 'flex', gap: 8, padding: 10 }}>
                                                                    <Button type="primary" size="small" onClick={() => applyCandidateAsResult(c)}>
                                                                        选这张
                                                                    </Button>
                                                                    <Button size="small" onClick={() => downloadDataUrl(c.dataUrl, `xobi_candidate_${c.index + 1}_${Date.now()}.png`)}>
                                                                        下载
                                                                    </Button>
                                                                </div>
                                                            </div>
                                                        ))}
                                                    </div>
                                                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginTop: 12 }}>
                                                        <Button size="small" onClick={() => setGuidedStage('plan')} disabled={guidedGenerating}>
                                                            换方向
                                                        </Button>
                                                        <Space size="small">
                                                            <Button size="small" onClick={handleGuidedExit} disabled={guidedGenerating}>
                                                                关闭引导
                                                            </Button>
                                                            <Button size="small" onClick={() => handleGuidedGenerateCandidates().catch(() => { })} loading={guidedGenerating}>
                                                                再生成一批
                                                            </Button>
                                                        </Space>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    )}
                                </div>

                                <div style={{
                                    background: 'var(--bg-tertiary)',
                                    borderRadius: 'var(--radius-l)',
                                    padding: '12px',
                                    border: '1px solid var(--border-color)'
                                }}>
                                    <div style={{ display: 'flex', gap: '8px', marginBottom: '10px' }}>
                                        <Tooltip title="添加/上传图片">
                                            <Button
                                                size="small"
                                                icon={<PictureOutlined />}
                                                onClick={handleBatchImportClick}
                                                style={{ background: 'var(--bg-elevated)', borderColor: 'var(--border-color)' }}
                                            />
                                        </Tooltip>
                                    </div>
                                    <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
                                        <Input
                                            placeholder={(() => {
                                                const q = (guidedStage === 'qa') ? (guidedQuestions || [])[guidedQuestionIndex] : null;
                                                if (guidedStage === 'qa' && q && (q.type === 'text' || q.type === 'text_optional')) return q.placeholder || '输入你的补充要求…';
                                                if (guidedStage === 'qa') return '请用上方按钮回答当前问题…';
                                                return '输入修改指令…（支持 @ 引用）';
                                            })()}
                                            value={inputValue}
                                            onChange={(e) => setInputValue(e.target.value)}
                                            onPressEnter={() => handleChatSend(inputValue)}
                                            disabled={guidedStage === 'qa' && ((guidedQuestions || [])[guidedQuestionIndex]?.type === 'choice')}
                                            style={{
                                                flex: 1,
                                                background: 'var(--bg-primary)',
                                                borderRadius: 'var(--radius-m)'
                                            }}
                                        />
                                        <Button
                                            type="primary"
                                            icon={<SendOutlined />}
                                            onClick={() => handleChatSend(inputValue)}
                                            loading={isGenerating}
                                            disabled={guidedStage === 'qa' && ((guidedQuestions || [])[guidedQuestionIndex]?.type === 'choice')}
                                            style={{
                                                height: '36px',
                                                width: '36px',
                                                borderRadius: 'var(--radius-m)',
                                                display: 'flex',
                                                alignItems: 'center',
                                                justifyContent: 'center'
                                            }}
                                        />
                                    </div>
                                    {false && (
                                        <div style={{
                                            marginTop: '10px',
                                            fontSize: '12px',
                                            color: 'var(--text-tertiary)',
                                            textAlign: 'center',
                                            padding: '8px',
                                            background: 'var(--bg-primary)',
                                            borderRadius: 'var(--radius-s)'
                                        }}>
                                            💡 请先上传图片，才能发送修改指令
                                        </div>
                                    )}
                                </div>
                            </div>
                        </Sider>
                        )}

                    </Layout >

                    {/* History Drawer */}
                    <Drawer
                        title={<span><BookOutlined /> 历史记录</span>}
                        placement="right"
                        width={400}
                        open={historyVisible}
                        onClose={() => setHistoryVisible(false)}
                        extra={
                            <Space>
                                <Button size="small" onClick={() => window.exportHistory && window.exportHistory()}>
                                    导出
                                </Button>
                                <Button size="small" danger onClick={() => {
                                    if (window.clearAllHistory) {
                                        window.clearAllHistory();
                                        setHistoryVisible(false);
                                    }
                                }}>
                                    清空
                                </Button>
                            </Space>
                        }
                    >
                        <div id="history-list" style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                            {(() => {
                                const sessions = window.chatHistoryManager ? window.chatHistoryManager.getAllSessions() : [];
                                if (sessions.length === 0) {
                                    return (
                                        <div style={{ textAlign: 'center', padding: '40px 20px', color: 'var(--text-tertiary)' }}>
                                            <div style={{ fontSize: '36px', marginBottom: '12px', opacity: 0.5 }}>📋</div>
                                            <div>暂无历史记录</div>
                                            <div style={{ fontSize: '12px', marginTop: '8px' }}>
                                                生成图片后会自动保存
                                            </div>
                                        </div>
                                    );
                                }
                                return sessions.map(session => (
                                    <Card key={session.id} size="small" style={{ background: 'var(--bg-tertiary)', borderColor: 'var(--border-color)' }}>
                                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                                <Avatar size="small" icon={<RobotOutlined />} />
                                                <span style={{ fontWeight: 600 }}>{session.title || '对话记录'}</span>
                                            </div>
                                            <Space size="small">
                                                <Button size="small" onClick={() => {
                                                    if (window.deleteHistorySession) {
                                                        window.deleteHistorySession(session.id);
                                                        setHistoryVisible(false);
                                                        setTimeout(() => setHistoryVisible(true), 100);
                                                    }
                                                }}>删除</Button>
                                                <Button type="primary" size="small" onClick={() => {
                                                    if (window.reopenSession) {
                                                        window.reopenSession(session.id);
                                                        setHistoryVisible(false);
                                                    }
                                                }}>重新打开</Button>
                                            </Space>
                                        </div>
                                        <List
                                            size="small"
                                            dataSource={session.messages || []}
                                            renderItem={(item, idx) => (
                                                <List.Item style={{ padding: '8px 0', borderBlockEnd: '1px solid var(--border-color)' }}>
                                                    <Space align="start">
                                                        <Tag color={item.role === 'user' ? 'blue' : 'purple'}>
                                                            {item.role === 'user' ? '用户' : 'AI'}
                                                        </Tag>
                                                        <div style={{ color: 'var(--text-secondary)', maxWidth: '260px', whiteSpace: 'pre-wrap' }}>
                                                            {item.content}
                                                        </div>
                                                    </Space>
                                                </List.Item>
                                            )}
                                        />
                                    </Card>
                                ));
                            })()}
                        </div>
                    </Drawer>

                    {/* Queue Drawer */}
                    <Drawer
                        title="任务队列"
                        placement="left"
                        width={720}
                        open={queueVisible}
                        onClose={() => setQueueVisible(false)}
                        extra={
                            <Space>
                                <Button type="primary" onClick={handleRunQueue}>
                                    ▶ 运行全部
                                </Button>
                                <Button onClick={handleClearQueue}>
                                    🗑 清空
                                </Button>
                            </Space>
                        }
                    >
                        <div style={{
                            display: 'grid',
                            gridTemplateColumns: 'repeat(5, 1fr)',
                            gap: '12px',
                            marginBottom: '20px'
                        }}>
                            <div style={{
                                background: 'var(--bg-tertiary)',
                                padding: '16px',
                                borderRadius: 'var(--radius-l)',
                                textAlign: 'center',
                                border: '1px solid var(--border-color)'
                            }}>
                                <div style={{ fontSize: '24px', fontWeight: 700, color: 'var(--text-primary)' }}>
                                    {queueTasks.length}
                                </div>
                                <div style={{ fontSize: '12px', color: 'var(--text-secondary)' }}>总计</div>
                            </div>
                            <div style={{
                                background: 'var(--bg-tertiary)',
                                padding: '16px',
                                borderRadius: 'var(--radius-l)',
                                textAlign: 'center',
                                border: '1px solid var(--border-color)'
                            }}>
                                <div style={{ fontSize: '24px', fontWeight: 700, color: 'var(--text-secondary)' }}>
                                    {queueTasks.filter(t => t.status === 'pending').length}
                                </div>
                                <div style={{ fontSize: '12px', color: 'var(--text-secondary)' }}>待处理</div>
                            </div>
                            <div style={{
                                background: 'var(--bg-tertiary)',
                                padding: '16px',
                                borderRadius: 'var(--radius-l)',
                                textAlign: 'center',
                                border: '1px solid var(--accent-color)'
                            }}>
                                <div style={{ fontSize: '24px', fontWeight: 700, color: 'var(--accent-color)' }}>
                                    {queueTasks.filter(t => t.status === 'processing').length}
                                </div>
                                <div style={{ fontSize: '12px', color: 'var(--accent-color)' }}>进行中</div>
                            </div>
                            <div style={{
                                background: 'var(--bg-tertiary)',
                                padding: '16px',
                                borderRadius: 'var(--radius-l)',
                                textAlign: 'center',
                                border: '1px solid #30d158'
                            }}>
                                <div style={{ fontSize: '24px', fontWeight: 700, color: '#30d158' }}>
                                    {queueTasks.filter(t => t.status === 'completed').length}
                                </div>
                                <div style={{ fontSize: '12px', color: '#30d158' }}>已完成</div>
                            </div>
                            <div style={{
                                background: 'var(--bg-tertiary)',
                                padding: '16px',
                                borderRadius: 'var(--radius-l)',
                                textAlign: 'center',
                                border: '1px solid #ff453a'
                            }}>
                                <div style={{ fontSize: '24px', fontWeight: 700, color: '#ff453a' }}>
                                    {queueTasks.filter(t => t.status === 'failed').length}
                                </div>
                                <div style={{ fontSize: '12px', color: '#ff453a' }}>失败</div>
                            </div>
                        </div>

                        {
                            queueTasks.length === 0 ? (
                                <div style={{
                                    textAlign: 'center',
                                    padding: '60px 20px',
                                    background: 'var(--bg-tertiary)',
                                    borderRadius: 'var(--radius-l)',
                                    border: '1px dashed var(--border-color)'
                                }}>
                                    <div style={{ fontSize: '48px', marginBottom: '16px', opacity: 0.5 }}>📋</div>
                                    <div style={{ fontSize: '16px', color: 'var(--text-secondary)', marginBottom: '8px' }}>
                                        队列为空
                                    </div>
                                    <div style={{ fontSize: '13px', color: 'var(--text-tertiary)' }}>
                                        点击“加入队列”按钮添加生成任务
                                    </div>
                                </div>
                            ) : (
                                <Table
                                    rowKey={(row, index) => row.id || index}
                                    dataSource={queueTasks}
                                    columns={[
                                        {
                                            title: '任务',
                                            dataIndex: 'type',
                                            key: 'type',
                                            render: (type) => {
                                                const types = { generation: '图片生成', annotation: '标注处理', modification: '修改任务' };
                                                return types[type] || type;
                                            }
                                        },
                                        {
                                            title: '状态',
                                            dataIndex: 'status',
                                            key: 'status',
                                            render: (status) => {
                                                const colors = {
                                                    pending: 'default',
                                                    processing: 'purple',
                                                    completed: 'green',
                                                    failed: 'red'
                                                };
                                                const labels = {
                                                    pending: '待处理',
                                                    processing: '处理中',
                                                    completed: '已完成',
                                                    failed: '失败'
                                                };
                                                return <Tag color={colors[status]}>{labels[status]}</Tag>;
                                            }
                                        },
                                        {
                                            title: '进度',
                                            dataIndex: 'status',
                                            key: 'progress',
                                            render: (status) => {
                                                const percent = status === 'completed' ? 100 : status === 'processing' ? 50 : 0;
                                                return <Progress
                                                    percent={percent}
                                                    size="small"
                                                    strokeColor={status === 'completed' ? '#30d158' : 'var(--accent-color)'}
                                                />;
                                            }
                                        }
                                    ]}
                                    pagination={false}
                                    size="small"
                                />
                            )
                        }
                    </Drawer>

                    {/* Project Profile Modal */}
                    <Modal
                        title="📌 品牌档案 / Project Profile"
                        open={profileOpen}
                        onCancel={() => setProfileOpen(false)}
                        width={820}
                        footer={[
                            <Button key="reset" onClick={handleResetProfile}>
                                重置
                            </Button>,
                            <Button key="cancel" onClick={() => setProfileOpen(false)}>
                                取消
                            </Button>,
                            <Button key="save" type="primary" onClick={handleSaveProfile}>
                                保存
                            </Button>
                        ]}
                    >
                        <Form form={profileForm} layout="vertical">
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '14px' }}>
                                <Form.Item label="项目名称（可选）" name="project_name">
                                    <Input placeholder="例如：Xobi 2026 春夏系列" allowClear />
                                </Form.Item>

                                <Form.Item label="默认语言" name="default_language">
                                    <Select
                                        options={[
                                            { label: '中文', value: 'zh' },
                                            { label: '英语', value: 'en' },
                                            { label: '泰语', value: 'th' }
                                        ]}
                                    />
                                </Form.Item>

                                <Form.Item label="常用产出" name="primary_outputs">
                                    <Select
                                        mode="multiple"
                                        placeholder="选择你最常做的类型"
                                        options={[
                                            { label: '海报 Poster', value: 'poster' },
                                            { label: 'Banner 横幅', value: 'banner' },
                                            { label: '电商主图', value: 'main' },
                                            { label: '社媒图', value: 'social' },
                                            { label: '详情页（后续）', value: 'detail' }
                                        ]}
                                    />
                                </Form.Item>

                                <Form.Item label="默认风格预设" name="default_style_preset">
                                    <Select
                                        options={[
                                            { label: '通用 Generic', value: 'generic' },
                                            { label: 'SHEIN', value: 'shein' },
                                            { label: 'Amazon', value: 'amazon' },
                                            { label: 'TikTok/抖音', value: 'tiktok' }
                                        ]}
                                    />
                                </Form.Item>

                                <Form.Item label="默认候选数量" name="default_candidate_count">
                                    <Radio.Group
                                        options={[
                                            { label: '1 张', value: 1 },
                                            { label: '4 张（推荐）', value: 4 }
                                        ]}
                                        optionType="button"
                                        buttonStyle="solid"
                                    />
                                </Form.Item>

                                <Form.Item label="产品保护等级" name="fidelity_level">
                                    <Radio.Group
                                        options={[
                                            { label: '严格（保形保色）', value: 'strict' },
                                            { label: '平衡（允许轻微角度）', value: 'balanced' }
                                        ]}
                                        optionType="button"
                                        buttonStyle="solid"
                                    />
                                </Form.Item>
                            </div>

                            <Form.Item label="品牌/视觉关键词（影响 AI 方向）" name="brand_style_keywords">
                                <TextArea rows={3} placeholder="例如：高级、干净、商业质感、自然光、留白充足、字体简洁…" />
                            </Form.Item>

                            <Form.Item label="禁止项（红线）" name="forbidden">
                                <TextArea rows={3} placeholder="例如：不要变形、不要偏色、不要新增任何Logo/水印/二维码…" />
                            </Form.Item>

                            <div style={{ fontSize: 12, color: 'var(--text-secondary)' }}>
                                说明：品牌档案会在「AI 引导生成」里自动带入，用来减少重复沟通。
                            </div>
                        </Form>
                    </Modal>

                    {/* Guided Generate Modal */}
                    {false && (
                    <Modal
                        title="🤖 AI 引导生成"
                        open={guidedOpen}
                        onCancel={() => {
                            if (guidedLoadingPlan || guidedGenerating) return;
                            setGuidedOpen(false);
                        }}
                        width={920}
                        footer={guidedStep === 0 ? [
                            <Button key="cancel" onClick={() => setGuidedOpen(false)} disabled={guidedLoadingPlan || guidedGenerating}>
                                取消
                            </Button>,
                            <Button key="plan" type="primary" loading={guidedLoadingPlan} onClick={handleGuidedBuildPlan}>
                                生成计划
                            </Button>
                        ] : [
                            <Button key="back" onClick={() => setGuidedStep(0)} disabled={guidedGenerating}>
                                返回问题
                            </Button>,
                            <Button key="gen" type="primary" loading={guidedGenerating} onClick={handleGuidedGenerateCandidates}>
                                生成候选
                            </Button>
                        ]}
                    >
                        <Steps
                            size="small"
                            current={guidedStep}
                            items={[
                                { title: '关键问题' },
                                { title: '计划与方向' }
                            ]}
                        />

                        <div style={{ marginTop: 16 }}>
                            {guidedStep === 0 && (
                                <Form form={guidedForm} layout="vertical">
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '14px' }}>
                                        <Form.Item
                                            label="本次产出类型"
                                            name="output_type"
                                            rules={[{ required: true, message: '请选择产出类型' }]}
                                        >
                                            <Select
                                                options={[
                                                    { label: '电商主图', value: 'main' },
                                                    { label: 'Banner 横幅', value: 'banner' },
                                                    { label: '海报 Poster', value: 'poster' },
                                                    { label: '社媒图', value: 'social' }
                                                ]}
                                            />
                                        </Form.Item>

                                        <Form.Item
                                            label="输出比例"
                                            name="aspect_ratio"
                                            rules={[{ required: true, message: '请选择比例' }]}
                                        >
                                            <Select
                                                options={[
                                                    { label: '1:1（主图/方图）', value: '1:1' },
                                                    { label: '16:9（横幅）', value: '16:9' },
                                                    { label: '9:16（竖版）', value: '9:16' },
                                                    { label: '3:4', value: '3:4' },
                                                    { label: '4:3', value: '4:3' }
                                                ]}
                                            />
                                        </Form.Item>

                                        <Form.Item
                                            label="目标语言（如不同则翻译文字）"
                                            name="target_language"
                                            rules={[{ required: true, message: '请选择语言' }]}
                                        >
                                            <Select
                                                options={[
                                                    { label: '保持原语言', value: 'same' },
                                                    { label: '中文', value: 'zh' },
                                                    { label: '英语', value: 'en' },
                                                    { label: '泰语', value: 'th' }
                                                ]}
                                            />
                                        </Form.Item>

                                        <Form.Item label="候选数量" name="candidate_count">
                                            <Radio.Group
                                                options={[
                                                    { label: '1 张', value: 1 },
                                                    { label: '4 张', value: 4 }
                                                ]}
                                                optionType="button"
                                                buttonStyle="solid"
                                            />
                                        </Form.Item>

                                        <Form.Item label="风格倾向" name="style_preset">
                                            <Select
                                                options={[
                                                    { label: '通用 Generic', value: 'generic' },
                                                    { label: 'SHEIN', value: 'shein' },
                                                    { label: 'Amazon', value: 'amazon' },
                                                    { label: 'TikTok/抖音', value: 'tiktok' }
                                                ]}
                                            />
                                        </Form.Item>

                                        <Form.Item label="产品保护" name="fidelity_level">
                                            <Radio.Group
                                                options={[
                                                    { label: '严格（保形保色）', value: 'strict' },
                                                    { label: '平衡（允许轻微角度）', value: 'balanced' }
                                                ]}
                                                optionType="button"
                                                buttonStyle="solid"
                                            />
                                        </Form.Item>

                                        {singleRefFile ? (
                                            <Form.Item label="参考图作为风格参考" name="use_reference" valuePropName="checked">
                                                <Switch />
                                            </Form.Item>
                                        ) : (
                                            <div />
                                        )}

                                        <Form.Item label="需要文字" name="text_enabled" valuePropName="checked">
                                            <Switch />
                                        </Form.Item>
                                    </div>

                                    <Form.Item noStyle shouldUpdate={(prev, cur) => prev.text_enabled !== cur.text_enabled}>
                                        {({ getFieldValue }) => getFieldValue('text_enabled') ? (
                                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '14px' }}>
                                                <Form.Item label="主标题（可选）" name="headline">
                                                    <Input placeholder="例如：新品上市" allowClear />
                                                </Form.Item>
                                                <Form.Item label="副标题（可选）" name="subheadline">
                                                    <Input placeholder="例如：限时优惠" allowClear />
                                                </Form.Item>
                                            </div>
                                        ) : null}
                                    </Form.Item>

                                    <Form.Item label="你想达成的效果（可选）" name="goal">
                                        <TextArea rows={3} placeholder="例如：更高级、更干净、留白多、偏科技、背景更有氛围…" />
                                    </Form.Item>
                                </Form>
                            )}

                            {guidedStep === 1 && (
                                <div>
                                    {Array.isArray(guidedPlan) && guidedPlan.length > 0 && (
                                        <div style={{ display: 'grid', gap: 10, marginBottom: 14 }}>
                                            {guidedPlan.map((p) => (
                                                <div
                                                    key={p.step}
                                                    style={{
                                                        border: '1px solid var(--border-color)',
                                                        borderRadius: 14,
                                                        background: 'var(--bg-tertiary)',
                                                        padding: '10px 12px'
                                                    }}
                                                >
                                                    <div style={{ fontWeight: 600 }}>{p.step}. {p.title}</div>
                                                    <div style={{ marginTop: 4, fontSize: 12, color: 'var(--text-secondary)' }}>{p.detail}</div>
                                                </div>
                                            ))}
                                        </div>
                                    )}

                                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, minmax(0, 1fr))', gap: 12 }}>
                                        {(guidedDirections || []).map((d) => (
                                            <div
                                                key={d.id}
                                                onClick={() => setGuidedSelectedId(d.id)}
                                                style={{
                                                    border: guidedSelectedId === d.id ? '1px solid var(--accent-color)' : '1px solid var(--border-color)',
                                                    borderRadius: 14,
                                                    background: guidedSelectedId === d.id ? 'rgba(59, 130, 246, 0.12)' : 'var(--bg-tertiary)',
                                                    padding: 12,
                                                    cursor: 'pointer'
                                                }}
                                            >
                                                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', gap: 8 }}>
                                                    <div style={{ fontWeight: 700 }}>{d.id}. {d.title}</div>
                                                    <Tag color="blue">{String(d.style_preset || 'generic')}</Tag>
                                                </div>
                                                <div style={{ marginTop: 6, fontSize: 12, color: 'var(--text-secondary)' }}>{d.summary}</div>
                                                <div style={{ marginTop: 10, fontSize: 12, color: 'var(--text-tertiary)' }}>
                                                    推荐比例：{d.recommended_aspect_ratio || '1:1'}
                                                </div>
                                            </div>
                                        ))}
                                    </div>

                                    <div style={{ marginTop: 12, fontSize: 12, color: 'var(--text-secondary)' }}>
                                        点击一个方向后，点右下角「生成候选」开始出图（默认 4 张）。
                                    </div>
                                </div>
                            )}
                        </div>
                    </Modal>
                    )}

                    {/* Candidate Picker */}
                    {false && (
                    <Modal
                        title="✅ 选择最终版本"
                        open={candidatePickerOpen}
                        onCancel={() => setCandidatePickerOpen(false)}
                        width={980}
                        footer={[
                            <Button key="close" onClick={() => setCandidatePickerOpen(false)}>
                                关闭
                            </Button>
                        ]}
                    >
                        {(!guidedCandidates || guidedCandidates.length === 0) ? (
                            <div style={{ color: 'var(--text-secondary)' }}>暂无候选，请先生成。</div>
                        ) : (
                            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, minmax(0, 1fr))', gap: 12 }}>
                                {guidedCandidates.map((c) => (
                                    <div
                                        key={c.index}
                                        style={{
                                            border: '1px solid var(--border-color)',
                                            borderRadius: 14,
                                            overflow: 'hidden',
                                            background: 'var(--bg-tertiary)'
                                        }}
                                    >
                                        <img src={c.dataUrl} style={{ width: '100%', display: 'block' }} draggable={false} />
                                        <div style={{ display: 'flex', gap: 8, padding: 10 }}>
                                            <Button type="primary" size="small" onClick={() => applyCandidateAsResult(c)}>
                                                选这张
                                            </Button>
                                            <Button size="small" onClick={() => downloadDataUrl(c.dataUrl, `xobi_candidate_${c.index + 1}_${Date.now()}.png`)}>
                                                下载
                                            </Button>
                                            {c.output_url ? (
                                                <Button size="small" onClick={() => window.open(c.output_url, '_blank')}>
                                                    打开输出
                                                </Button>
                                            ) : null}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </Modal>
                    )}

                    {/* Preview Modal */}
                    <Modal
                        title="🔍 实时预览"
                        open={previewVisible}
                        onCancel={() => setPreviewVisible(false)}
                        footer={[
                            <Button key="close" onClick={() => setPreviewVisible(false)}>
                                关闭
                            </Button>,
                            <Button key="apply" type="primary" onClick={() => {
                                setPreviewVisible(false);
                                handleGenerate();
                            }}>
                                应用并生成高清图
                            </Button>
                        ]}
                        width={800}
                    >
                        {previewImage && (
                            <div style={{ textAlign: 'center' }}>
                                <img src={previewImage} style={{ maxWidth: '100%', borderRadius: '8px' }} />
                            </div>
                        )}
                    </Modal>

                    {/* Queue Float Button - 左下角位置 */}
                    {queueTasks.length > 0 && (
                        <Badge count={queueTasks.length} offset={[-10, 10]}>
                            <FloatButton
                                icon="📋"
                                type="primary"
                                onClick={() => setQueueVisible(true)}
                                style={{ left: 24, right: 'auto', bottom: 24 }}
                            />
                        </Badge>
                    )}

                    {/* 图片预览 Modal */}
                    <Modal
                        open={!!previewImage}
                        footer={null}
                        onCancel={() => setPreviewImage(null)}
                        width="90vw"
                        style={{ top: 20 }}
                        bodyStyle={{ padding: 0, background: '#000', display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '80vh' }}
                        title={previewImage?.title || '图片预览'}
                    >
                        {previewImage && (
                            <img
                                src={previewImage.src}
                                alt={previewImage.title}
                                style={{ maxWidth: '100%', maxHeight: '80vh', objectFit: 'contain' }}
                            />
                        )}
                    </Modal>

                    {/* 快捷键帮助 Modal */}
                    <Modal
                        open={helpModalOpen}
                        footer={null}
                        onCancel={() => setHelpModalOpen(false)}
                        width={600}
                        title={<><span style={{ marginRight: 8 }}>⌨️</span>快捷键帮助</>}
                    >
                        <div style={{ maxHeight: '60vh', overflow: 'auto' }}>
                            {shortcutHelpData.map((group, idx) => (
                                <div key={idx} style={{ marginBottom: 20 }}>
                                    <div style={{ fontWeight: 'bold', fontSize: 14, marginBottom: 8, color: '#1890ff' }}>
                                        {group.category}
                                    </div>
                                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 8 }}>
                                        {group.shortcuts.map((s, i) => (
                                            <div key={i} style={{ display: 'flex', justifyContent: 'space-between', padding: '6px 12px', background: 'rgba(255,255,255,0.05)', borderRadius: 4 }}>
                                                <code style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 8px', borderRadius: 4, fontSize: 12 }}>{s.key}</code>
                                                <span style={{ opacity: 0.8, fontSize: 13 }}>{s.desc}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                        <div style={{ textAlign: 'center', marginTop: 16, opacity: 0.6 }}>
                            按 <code style={{ background: 'rgba(255,255,255,0.1)', padding: '2px 8px', borderRadius: 4 }}>Esc</code> 关闭此窗口
                        </div>
                    </Modal>

                    {/* 图层面板 Drawer */}
                    <Drawer
                        title={<><OrderedListOutlined style={{ marginRight: 8 }} />图层面板</>}
                        open={layerPanelOpen}
                        onClose={() => setLayerPanelOpen(false)}
                        width={280}
                        placement="right"
                        mask={false}
                        style={{ background: 'var(--bg-secondary)' }}
                        bodyStyle={{ padding: 0, background: 'var(--bg-secondary)' }}
                        headerStyle={{ background: 'var(--bg-secondary)', borderColor: 'var(--border-color)' }}
                    >
                        <div style={{ padding: '12px', fontSize: 12, color: 'var(--text-secondary)', borderBottom: '1px solid var(--border-color)' }}>
                            共 {nodes.length} 个节点 {selectedNodeIds.length > 0 && `(已选 ${selectedNodeIds.length})`}
                        </div>
                        <div style={{ maxHeight: 'calc(100vh - 160px)', overflow: 'auto' }}>
                            {nodes.slice().reverse().map((node, idx) => {
                                const isSelected = selectedNodeIds.includes(node.id);
                                const isLocked = lockedNodeIds.includes(node.id);
                                const nodeTypeLabels = {
                                    'reference': '参考主图',
                                    'product': '我的产品',
                                    'result': '生成结果',
                                    'batch': '批量素材',
                                    'board': '画板'
                                };
                                const nodeTypeIcons = {
                                    'reference': <FileImageOutlined />,
                                    'product': <ShoppingOutlined />,
                                    'result': <PictureOutlined />,
                                    'batch': <AppstoreOutlined />,
                                    'board': <BorderOutlined />
                                };
                                return (
                                    <div
                                        key={node.id}
                                        onClick={(e) => {
                                            if (e.ctrlKey || e.metaKey) {
                                                toggleSelection(node.id);
                                            } else {
                                                setSingleSelection(node.id);
                                            }
                                        }}
                                        style={{
                                            display: 'flex',
                                            alignItems: 'center',
                                            padding: '10px 12px',
                                            cursor: 'pointer',
                                            background: isSelected ? 'rgba(59, 130, 246, 0.2)' : 'transparent',
                                            borderBottom: '1px solid var(--border-color)',
                                            transition: 'background 0.15s'
                                        }}
                                        onMouseEnter={(e) => {
                                            if (!isSelected) e.currentTarget.style.background = 'rgba(255,255,255,0.05)';
                                        }}
                                        onMouseLeave={(e) => {
                                            if (!isSelected) e.currentTarget.style.background = 'transparent';
                                        }}
                                    >
                                        <span style={{ marginRight: 8, color: isSelected ? '#3b82f6' : 'var(--text-tertiary)' }}>
                                            {nodeTypeIcons[node.type] || <AppstoreOutlined />}
                                        </span>
                                        <span style={{ flex: 1, fontSize: 13, color: isSelected ? '#fff' : 'var(--text-primary)' }}>
                                            {nodeTypeLabels[node.type] || node.type}
                                            {node.groupId && <span style={{ marginLeft: 6, fontSize: 11, color: '#1890ff' }}>●</span>}
                                        </span>
                                        <span style={{ display: 'flex', gap: 4 }}>
                                            {isLocked && <LockOutlined style={{ fontSize: 12, color: '#faad14' }} />}
                                            <Tooltip title={isLocked ? '解锁' : '锁定'}>
                                                <Button
                                                    type="text"
                                                    size="small"
                                                    icon={isLocked ? <UnlockOutlined /> : <LockOutlined />}
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        if (isLocked) {
                                                            setLockedNodeIds(prev => prev.filter(id => id !== node.id));
                                                        } else {
                                                            setLockedNodeIds(prev => [...prev, node.id]);
                                                        }
                                                    }}
                                                    style={{ color: 'var(--text-tertiary)', minWidth: 24, padding: 0 }}
                                                />
                                            </Tooltip>
                                            <Tooltip title="上移图层">
                                                <Button
                                                    type="text"
                                                    size="small"
                                                    icon={<ArrowUpOutlined />}
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleBringForward([node.id]);
                                                    }}
                                                    disabled={idx === 0}
                                                    style={{ color: 'var(--text-tertiary)', minWidth: 24, padding: 0 }}
                                                />
                                            </Tooltip>
                                            <Tooltip title="下移图层">
                                                <Button
                                                    type="text"
                                                    size="small"
                                                    icon={<ArrowDownOutlined />}
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleSendBackward([node.id]);
                                                    }}
                                                    disabled={idx === nodes.length - 1}
                                                    style={{ color: 'var(--text-tertiary)', minWidth: 24, padding: 0 }}
                                                />
                                            </Tooltip>
                                        </span>
                                    </div>
                                );
                            })}
                        </div>
                        {/* 图层面板底部操作 */}
                        <div style={{ padding: '12px', borderTop: '1px solid var(--border-color)', display: 'flex', gap: 8, flexWrap: 'wrap' }}>
                            <Button size="small" onClick={() => setSelectedNodeIds(nodes.map(n => n.id))} disabled={nodes.length === 0}>
                                全选
                            </Button>
                            <Button size="small" onClick={() => setSelectedNodeIds([])} disabled={selectedNodeIds.length === 0}>
                                取消选择
                            </Button>
                            <Button size="small" danger onClick={() => handleDeleteNodes()} disabled={selectedNodeIds.length === 0}>
                                删除选中
                            </Button>
                        </div>
                    </Drawer>

                </Layout>
            );
        }

        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>
